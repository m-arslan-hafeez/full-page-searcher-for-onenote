<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ICU4N.Collation</name>
    </assembly>
    <members>
        <member name="T:ICU4N.Impl.Coll.BOCSU">
            <summary>
            Binary Ordered Compression Scheme for Unicode
            <para/>
            Users are strongly encouraged to read the ICU paper on
            <a href="http://www.icu-project.org/docs/papers/binary_ordered_compression_for_unicode.html">
            BOCU</a> before attempting to use this class.
            </summary>
            <remarks>
            BOCU is used to compress unicode text into a stream of unsigned
            bytes.  For many kinds of text the compression compares favorably
            to UTF-8, and for some kinds of text (such as CJK) it does better.
            The resulting bytes will compare in the same order as the original
            code points.  The byte stream does not contain the values 0, 1, or
            2.
            <para/>
            One example of a use of BOCU is in <see cref="M:ICU4N.Text.Collator.GetCollationKey(System.String)"/>
            for a <see cref="T:ICU4N.Text.RuleBasedCollator"/> object with collation strength
            <see cref="F:ICU4N.Text.CollationStrength.Identical"/>. The result <see cref="T:ICU4N.Text.CollationKey"/> 
            will consist of the collation order of the source string followed by the BOCU result of the 
            source string.
            <para/>
            Unlike a UTF encoding, BOCU-compressed text is not suitable for
            random access.
            <para/>
            Method: Slope Detection<br/> Remember the previous code point
            (initial 0).  For each code point in the string, encode the
            difference with the previous one.  Similar to a UTF, the length of
            the byte sequence is encoded in the lead bytes.  Unlike a UTF, the
            trail byte values may overlap with lead/single byte values.  The
            trail byte values may overlap with lead/single byte values.  The
            significant part.
            <para/>
            We encode differences with few bytes if their absolute values
            are small.  For correct ordering, we must treat the entire value
            range -10ffff..+10ffff in ascending order, which forbids encoding
            the sign and the absolute value separately. Instead, we split the
            lead byte range in the middle and encode non-negative values going
            up and negative values going down.
            <para/>
            For very small absolute values, the difference is added to a
            middle byte value for single-byte encoded differences.  For
            somewhat larger absolute values, the difference is divided by the
            number of byte values available, the modulo is used for one trail
            byte, and the remainder is added to a lead byte avoiding the
            single-byte range.  For large absolute values, the difference is
            similarly encoded in three bytes. (Syn Wee, I need examples
            here.)
            <para/>
            BOCU does not use byte values 0, 1, or 2, but uses all other
            byte values for lead and single bytes, so that the middle range of
            single bytes is as large as possible.
            <para/>
            Note that the lead byte ranges overlap some, but that the
            sequences as a whole are well ordered. I.e., even if the lead byte
            is the same for sequences of different lengths, the trail bytes
            establish correct order.  It would be possible to encode slightly
            larger ranges for each length (>1) by subtracting the lower bound
            of the range. However, that would also slow down the calculation.
            (Syn Wee, need an example).
            <para/>
            For the actual string encoding, an optimization moves the
            previous code point value to the middle of its Unicode script block
            to minimize the differences in same-script text runs.  (Syn Wee,
            need an example.)
            </remarks>
            <author>Syn Wee Quek</author>
            <since>release 2.2, May 3rd 2002</since>
        </member>
        <member name="M:ICU4N.Impl.Coll.BOCSU.WriteIdenticalLevelRun(System.Int32,ICU4N.Support.Text.ICharSequence,System.Int32,System.Int32,ICU4N.Util.ByteArrayWrapper)">
            <summary>
            Encode the code points of a string as
            a sequence of byte-encoded differences (slope detection),
            preserving lexical order.
            </summary>
            <remarks>
            Optimize the difference-taking for runs of Unicode text within
            small scripts:
            <para/>
            Most small scripts are allocated within aligned 128-blocks of Unicode
            code points. Lexical order is preserved if "prev" is always moved
            into the middle of such a block.
            <para/>
            Additionally, "prev" is moved from anywhere in the Unihan
            area into the middle of that area.
            Note that the identical-level run in a sort key is generated from
            NFD text - there are never Hangul characters included.
            </remarks>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_MIN_">
            <summary>
            Do not use byte values 0, 1, 2 because they are separators in sort keys.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_SINGLE_">
            <summary>
            Number of lead bytes:
            1        middle byte for 0
            2*80=160 single bytes for !=0
            2*42=84  for double-byte values
            2*3=6    for 3-byte values
            2*1=2    for 4-byte values
            <para/>
            The sum must be &lt;=SLOPE_TAIL_COUNT.
            <para/>
            Why these numbers?
            - There should be >=128 single-byte values to cover 128-blocks
              with small scripts.
            - There should be >=20902 single/double-byte values to cover Unihan.
            - It helps CJK Extension B some if there are 3-byte values that cover
              the distance between them and Unihan.
              This also helps to jump among distant places in the BMP.
            - Four-byte values are necessary to cover the rest of Unicode.
            <para/>
            Symmetrical lead byte counts are for convenience.
            With an equal distribution of even and odd differences there is also
            no advantage to asymmetrical lead byte counts.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_REACH_POS_1_">
            <summary>
            The difference value range for single-byters.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_REACH_POS_2_">
            <summary>
            The difference value range for double-byters.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_REACH_POS_3_">
            <summary>
            The difference value range for 3-byters.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.BOCSU.SLOPE_START_POS_2_">
            <summary>
            The lead byte start values.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.BOCSU.GetNegDivMod(System.Int32,System.Int32)">
            <summary>
            Integer division and modulo with negative numerators
            yields negative modulo results and quotients that are one more than
            what we need here.
            </summary>
            <param name="number">Which operations are to be performed on.</param>
            <param name="factor">The factor to use for division.</param>
            <returns>(result of division) &lt;&lt; 32 | modulo</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.BOCSU.WriteDiff(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Encode one difference value -0x10ffff..+0x10ffff in 1..4 bytes,
            preserving lexical order.
            </summary>
            <param name="diff"></param>
            <param name="buffer">Byte buffer to append to.</param>
            <param name="offset">Offset to the byte buffer to start appending.</param>
            <returns>End offset where the appending stops.</returns>
        </member>
        <member name="T:ICU4N.Impl.Coll.Collation">
            <summary>
            Collation v2 basic definitions and static helper functions.
            <para/>
            Data structures except for expansion tables store 32-bit CEs which are
            either specials (see tags below) or are compact forms of 64-bit CEs.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.SENTINEL_CP">
            <summary>
            UChar32 U_SENTINEL.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.BEFORE_WEIGHT16">
            <summary>The secondary/tertiary lower limit for tailoring before any root elements.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.MERGE_SEPARATOR_BYTE">
            <summary>
            Merge-sort-key separator.
            Same as the unique primary and identical-level weights of U+FFFE.
            Must not be used as primary compression low terminator.
            Otherwise usable.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.PRIMARY_COMPRESSION_LOW_BYTE">
            <summary>
            Primary compression low terminator, must be greater than <see cref="F:ICU4N.Impl.Coll.Collation.MERGE_SEPARATOR_BYTE"/>.
            Reserved value in primary second byte if the lead byte is compressible.
            Otherwise usable in all CE weight bytes.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.PRIMARY_COMPRESSION_HIGH_BYTE">
            <summary>
            Primary compression high terminator.
            Reserved value in primary second byte if the lead byte is compressible.
            Otherwise usable in all CE weight bytes.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.COMMON_BYTE">
            <summary>Default secondary/tertiary weight lead byte.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.COMMON_SECONDARY_CE">
            <summary>Middle 16 bits of a CE with a common secondary weight.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.COMMON_TERTIARY_CE">
            <summary>Lower 16 bits of a CE with a common tertiary weight.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.COMMON_SEC_AND_TER_CE">
            <summary>Lower 32 bits of a CE with common secondary and tertiary weights.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.ONLY_TERTIARY_MASK">
            <summary>Only the 2*6 bits for the pure tertiary weight.</summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.Coll.Collation.ONLY_SEC_TER_MASK" -->
        <member name="F:ICU4N.Impl.Coll.Collation.CASE_AND_TERTIARY_MASK">
            <summary>Case bits and tertiary bits.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CASE_AND_QUATERNARY_MASK">
            <summary>Case bits and quaternary bits.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.FIRST_UNASSIGNED_PRIMARY">
            <summary>
            First unassigned: AlphabeticIndex overflow boundary.
            We want a 3-byte primary so that it fits into the root elements table.
            <para/>
            This 3-byte primary will not collide with
            any unassigned-implicit 4-byte primaries because
            the first few hundred Unicode code points all have real mappings.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.SPECIAL_CE32_LOW_BYTE">
            <summary>
            A CE32 is special if its low byte is this or greater.
            Impossible case bits 11 mark special CE32s.
            This value itself is used to indicate a fallback to the base collator.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LONG_PRIMARY_CE32_LOW_BYTE">
            <summary>
            Low byte of a long-primary special CE32.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.NO_CE_PRIMARY">
            <summary>No CE: End of input. Only used in runtime code, not stored in data.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.NO_LEVEL">
            Sort key levels. 
            <summary>Unspecified level.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.ZERO_LEVEL">
            <summary>Beyond sort key bytes.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.NO_LEVEL_FLAG">
            <summary>
            Sort key level flags: xx_FLAG = 1 &lt;&lt; xx_LEVEL.
            In Java, use enum Level with flag() getters, or use EnumSet rather than hand-made bit sets.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.FALLBACK_TAG">
            Special-CE32 tags, from bits 3..0 of a special 32-bit CE.
            Bits 31..8 are available for tag-specific data.
            Bits  5..4: Reserved. May be used in the future to indicate lccc!=0 and tccc!=0.
            <summary>
            Fall back to the base collator.
            This is the tag value in <see cref="F:ICU4N.Impl.Coll.Collation.SPECIAL_CE32_LOW_BYTE"/> and <see cref="F:ICU4N.Impl.Coll.Collation.FALLBACK_CE32"/>.
            Bits 31..8: Unused, 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LONG_PRIMARY_TAG">
            <summary>
            Long-primary CE with <see cref="F:ICU4N.Impl.Coll.Collation.COMMON_SEC_AND_TER_CE"/>.
            Bits 31..8: Three-byte primary.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LONG_SECONDARY_TAG">
            <summary>
            Long-secondary CE with zero primary.
            Bits 31..16: Secondary weight.
            Bits 15.. 8: Tertiary weight.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.RESERVED_TAG_3">
            <summary>
            Unused.
            May be used in the future for single-byte secondary CEs (SHORT_SECONDARY_TAG),
            storing the secondary in bits 31..24, the ccc in bits 23..16,
            and the tertiary in bits 15..8.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LATIN_EXPANSION_TAG">
            <summary>
            Latin mini expansions of two simple CEs [pp, 05, tt] [00, ss, 05].
            Bits 31..24: Single-byte primary weight pp of the first CE.
            Bits 23..16: Tertiary weight tt of the first CE.
            Bits 15.. 8: Secondary weight ss of the second CE.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.EXPANSION32_TAG">
            <summary>
            Points to one or more simple/long-primary/long-secondary 32-bit CE32s.
            Bits 31..13: Index into int table.
            Bits 12.. 8: Length=1..31.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.EXPANSION_TAG">
            <summary>
            Points to one or more 64-bit CEs.
            Bits 31..13: Index into CE table.
            Bits 12.. 8: Length=1..31.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.BUILDER_DATA_TAG">
            <summary>
            Builder data, used only in the CollationDataBuilder, not in runtime data.
            <para/>
            If bit 8 is 0: Builder context, points to a list of context-sensitive mappings.
            Bits 31..13: Index to the builder's list of ConditionalCE32 for this character.
            Bits 12.. 9: Unused, 0.
            <para/>
            If bit 8 is 1 (IS_BUILDER_JAMO_CE32): Builder-only jamoCE32 value.
            The builder fetches the Jamo CE32 from the trie.
            Bits 31..13: Jamo code point.
            Bits 12.. 9: Unused, 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.PREFIX_TAG">
            <summary>
            Points to prefix trie.
            Bits 31..13: Index into prefix/contraction data.
            Bits 12.. 8: Unused, 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CONTRACTION_TAG">
            <summary>
            Points to contraction data.
            Bits 31..13: Index into prefix/contraction data.
            Bits 12..11: Unused, 0.
            Bit      10: CONTRACT_TRAILING_CCC flag.
            Bit       9: CONTRACT_NEXT_CCC flag.
            Bit       8: CONTRACT_SINGLE_CP_NO_MATCH flag.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.DIGIT_TAG">
            <summary>
            Decimal digit.
            Bits 31..13: Index into int table for non-numeric-collation CE32.
            Bit      12: Unused, 0.
            Bits 11.. 8: Digit value 0..9.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.U0000_TAG">
            <summary>
            Tag for U+0000, for moving the NUL-termination handling
            from the regular fastpath into specials-handling code.
            Bits 31..8: Unused, 0.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.HANGUL_TAG">
            <summary>
            Tag for a Hangul syllable.
            Bits 31..9: Unused, 0.
            Bit      8: HANGUL_NO_SPECIAL_JAMO flag.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.LEAD_SURROGATE_TAG">
            <summary>
            Tag for a lead surrogate code unit.
            Optional optimization for UTF-16 string processing.
            Bits 31..10: Unused, 0.
                  9.. 8: =0: All associated supplementary code points are unassigned-implict.
                         =1: All associated supplementary code points fall back to the base data.
                         else: (Normally 2) Look up the data for the supplementary code point.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.OFFSET_TAG">
            <summary>
            Tag for CEs with primary weights in code point order.
            Bits 31..13: Index into CE table, for one data "CE".
            Bits 12.. 8: Unused, 0.
            <para/>
            This data "CE" has the following bit fields:
            Bits 63..32: Three-byte primary pppppp00.
                 31.. 8: Start/base code point of the in-order range.
                      7: Flag isCompressible primary.
                  6.. 0: Per-code point primary-weight increment.          
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.IMPLICIT_TAG">
            <summary>
            Implicit CE tag. Compute an unassigned-implicit CE.
            All bits are set (UNASSIGNED_CE32=0xffffffff).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.MAX_EXPANSION_LENGTH">
            <summary>
            We limit the number of CEs in an expansion
            so that we can use a small number of length bits in the data structure,
            and so that an implementation can copy CEs at runtime without growing a destination buffer.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CONTRACT_SINGLE_CP_NO_MATCH">
            <summary>
            Set if there is no match for the single (no-suffix) character itself.
            This is only possible if there is a prefix.
            In this case, discontiguous contraction matching cannot add combining marks
            starting from an empty suffix.
            The default CE32 is used anyway if there is no suffix match.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CONTRACT_NEXT_CCC">
            <summary>Set if the first character of every contraction suffix has lccc!=0.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.CONTRACT_TRAILING_CCC">
            <summary>Set if any contraction suffix ends with lccc!=0.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.Collation.HANGUL_NO_SPECIAL_JAMO">
            <summary>For HANGUL_TAG: None of its Jamo CE32s <see cref="M:ICU4N.Impl.Coll.Collation.IsSpecialCE32(System.Int32)"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.PrimaryFromLongPrimaryCE32(System.Int32)">
            <summary>Turns the long-primary CE32 into a primary weight pppppp00.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.MakeCE32FromTagIndexAndLength(System.Int32,System.Int32,System.Int32)">
            <summary>Makes a special CE32 with <paramref name="tag"/>, <paramref name="index"/> and <paramref name="length"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.MakeCE32FromTagAndIndex(System.Int32,System.Int32)">
            <summary>Makes a special CE32 with only <paramref name="tag"/> and <paramref name="index"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.IsSelfContainedCE32(System.Int32)">
            <returns>true if the ce32 yields one or more CEs without further data lookups.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.LatinCE0FromCE32(System.Int32)">
            <summary>
            Get the first of the two Latin-expansion CEs encoded in ce32.
            </summary>
            <seealso cref="F:ICU4N.Impl.Coll.Collation.LATIN_EXPANSION_TAG"/>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.LatinCE1FromCE32(System.Int32)">
            <summary>
            Get the second of the two Latin-expansion CEs encoded in ce32.
            </summary>
            <seealso cref="F:ICU4N.Impl.Coll.Collation.LATIN_EXPANSION_TAG"/>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.IndexFromCE32(System.Int32)">
            <summary>
            Returns the data index from a special CE32.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.LengthFromCE32(System.Int32)">
            <summary>
            Returns the data length from a ce32.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.DigitFromCE32(System.Int32)">
            <summary>
            Returns the digit value from a <see cref="F:ICU4N.Impl.Coll.Collation.DIGIT_TAG"/> ce32.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.CeFromSimpleCE32(System.Int32)">
            <summary>Returns a 64-bit CE from a simple CE32 (not special).</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.CeFromCE32(System.Int32)">
            <summary>Returns a 64-bit CE from a simple/long-primary/long-secondary CE32.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.MakeCE(System.Int64)">
            <summary>Creates a CE from a primary weight.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.MakeCE(System.Int64,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a CE from a primary weight,
            16-bit secondary/tertiary weights, and a 2-bit quaternary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.IncTwoBytePrimaryByOffset(System.Int64,System.Boolean,System.Int32)">
            <summary>
            Increments a 2-byte primary by a code point offset.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.IncThreeBytePrimaryByOffset(System.Int64,System.Boolean,System.Int32)">
            <summary>
            Increments a 3-byte primary by a code point offset.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.DecTwoBytePrimaryByOneStep(System.Int64,System.Boolean,System.Int32)">
            <summary>
            Decrements a 2-byte primary by one range step (1..0x7f).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.DecThreeBytePrimaryByOneStep(System.Int64,System.Boolean,System.Int32)">
            <summary>
            Decrements a 3-byte primary by one range step (1..0x7f).
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.GetThreeBytePrimaryForOffsetData(System.Int32,System.Int64)">
            <summary>
            Computes a 3-byte primary for c's OFFSET_TAG data "CE".
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.Collation.UnassignedPrimaryFromCodePoint(System.Int32)">
            <summary>
            Returns the unassigned-character implicit primary weight for any valid code point c.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.AddReset(ICU4N.Text.CollationStrength,ICU4N.Support.Text.ICharSequence)">
            <summary>Implements CollationRuleParser.Sink.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.GetWeight16Before(System.Int32,System.Int64,ICU4N.Text.CollationStrength)">
            <summary>
            Returns the secondary or tertiary weight preceding the current node's weight.
            node=nodes[index].
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.AddRelation(ICU4N.Text.CollationStrength,ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence,System.String)">
            <summary>Implements CollationRuleParser.Sink.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FindOrInsertNodeForCEs(ICU4N.Text.CollationStrength)">
            <summary>
            Picks one of the current CEs and finds or inserts a node in the graph
            for the CE + strength.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.BinarySearchForRootPrimaryNode(System.Collections.Generic.IList{System.Int32},System.Int32,System.Collections.Generic.IList{System.Int64},System.Int64)">
            <summary>
            Like Java Collections.binarySearch(List, key, Comparator).
            </summary>
            <returns>The index>=0 where the item was found,
            or the index&lt;0 for inserting the string at ~index in sorted order
            (index into rootPrimaryIndexes)</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FindOrInsertNodeForPrimary(System.Int64)">
            <summary>Finds or inserts the node for a root CE's primary weight.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FindOrInsertWeakNode(System.Int32,System.Int32,ICU4N.Text.CollationStrength)">
            <summary>Finds or inserts the node for a secondary or tertiary weight.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.InsertTailoredNodeAfter(System.Int32,ICU4N.Text.CollationStrength)">
            <summary>
            Makes and inserts a new tailored node into the list, after the one at <paramref name="index"/>.
            Skips over nodes of weaker strength to maintain collation order
            ("postpone insertion").
            </summary>
            <returns>The new node's index.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.InsertNodeBetween(System.Int32,System.Int32,System.Int64)">
            <summary>
            Inserts a new node into the list, between list-adjacent items.
            The node's previous and next indexes must not be set yet.
            </summary>
            <returns>The new node's index.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FindCommonNode(System.Int32,ICU4N.Text.CollationStrength)">
            <summary>
            Finds the node which implies or contains a common=05 weight of the given <paramref name="strength"/>
            (secondary or tertiary), if the current node is stronger.
            Skips weaker nodes and tailored nodes if the current node is stronger
            and is followed by an explicit-common-weight node.
            Always returns the input <paramref name="index"/> if that node is no stronger than the given <paramref name="strength"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.SuppressContractions(ICU4N.Text.UnicodeSet)">
            <summary>Implements <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.Sink"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.Optimize(ICU4N.Text.UnicodeSet)">
            <summary>Implements <see cref="T:ICU4N.Impl.Coll.CollationRuleParser.Sink"/>.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.AddWithClosure(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Adds the mapping and its canonical closure.
            Takes ce32=dataBuilder.EncodeCEs(...) so that the data builder
            need not re-encode the CEs multiple times.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.MakeTailoredCEs">
            <summary>
            Walks the tailoring graph and overwrites tailored nodes with new CEs.
            After this, the graph is destroyed.
            The nodes array can then be used only as a source of tailored CEs.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.CountTailoredNodes(System.Collections.Generic.IList{System.Int64},System.Int32,ICU4N.Text.CollationStrength)">
            <summary>
            Counts the tailored nodes of the given strength up to the next node
            which is either stronger or has an explicit weight of this <paramref name="strength"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.FinalizeCEs">
            <summary>Replaces temporary CEs with the final CEs they point to.</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationBuilder.TempCEFromIndexAndStrength(System.Int32,ICU4N.Text.CollationStrength)">
            <summary>
            Encodes "temporary CE" data into a CE that fits into the CE32 data structure,
            with 2-byte primary, 1-byte secondary and 6-bit tertiary,
            with valid CE byte values.
            <para/>
            The index must not exceed 20 bits (0xfffff).
            The strength must fit into 2 bits (<see cref="F:ICU4N.Text.CollationStrength.Primary"/>..<see cref="F:ICU4N.Text.CollationStrength.Quaternary"/>).
            <para/>
            Temporary CEs are distinguished from real CEs by their use of
            secondary weights 06..45 which are otherwise reserved for compressed sort keys.
            <para/>
            The case bits are unused and available.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.MAX_INDEX">
            <summary>At most 1M nodes, limited by the 20 bits in node bit fields.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.HAS_BEFORE2">
            <summary>
            Node bit 6 is set on a primary node if there are nodes
            with secondary values below the common secondary weight (05).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.HAS_BEFORE3">
            <summary>
            Node bit 5 is set on a primary or secondary node if there are nodes
            with tertiary values below the common tertiary weight (05).
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.IS_TAILORED">
            <summary>
            Node bit 3 distinguishes a tailored node, which has no weight value,
            from a node with an explicit (root or default) weight.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.rootPrimaryIndexes">
            <summary>
            Indexes of nodes with root primary weights, sorted by primary.
            Compact form of a <see cref="T:System.Collections.Generic.SortedDictionary`2"/> from root primary to node index.
            <para/>
            This is a performance optimization for finding reset positions.
            Without this, we would have to search through the entire nodes list.
            It also allows storing root primary weights in list head nodes,
            without previous index, leaving room in root primary nodes for 32-bit primary weights.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationBuilder.nodes">
            <summary>
            Data structure for assigning tailored weights and CEs.
            Doubly-linked lists of nodes in mostly collation order.
            Each list starts with a root primary node and ends with a nextIndex of 0.
            </summary>
            <remarks>
            When there are any nodes in the list, then there is always a root primary node at index 0.
            This allows some code not to have to check explicitly for nextIndex==0.
            <para/>
            Root primary nodes have 32-bit weights but do not have previous indexes.
            All other nodes have at most 16-bit weights and do have previous indexes.
            <para/>
            Nodes with explicit weights store root collator weights,
            or default weak weights (e.g., secondary 05) for stronger nodes.
            "Tailored" nodes, with the IS_TAILORED bit set,
            do not store explicit weights but rather
            create a difference of a certain strength from the preceding node.
            <para/>
            A root node is followed by either
            - a root/default node of the same strength, or
            - a root/default node of the next-weaker strength, or
            - a tailored node of the same strength.
            <para/>
            A node of a given strength normally implies "common" weights on weaker levels.
            <para/>
            A node with HAS_BEFORE2 must be immediately followed by
            a secondary node with an explicit below-common weight, then a secondary tailored node,
            and later an explicit common-secondary node.
            The below-common weight can be a root weight,
            or it can be BEFORE_WEIGHT16 for tailoring before an implied common weight
            or before the lowest root weight.
            (&amp;[before 2] resets to an explicit secondary node so that
            the following addRelation(secondary) tailors right after that.
            If we did not have this node and instead were to reset on the primary node,
            then addRelation(secondary) would skip forward to the the COMMON_WEIGHT16 node.)
            <para/>
            If the flag is not set, then there are no explicit secondary nodes
            with the common or lower weights.
            <para/>
            Same for HAS_BEFORE3 for tertiary nodes and weights.
            A node must not have both flags set.
            <para/>
            Tailored CEs are initially represented in a CollationDataBuilder as temporary CEs
            which point to stable indexes in this list,
            and temporary CEs stored in a CollationDataBuilder only point to tailored nodes.
            <para/>
            A temporary CE in the ces[] array may point to a non-tailored reset-before-position node,
            until the next relation is added.
            <para/>
            At the end, the tailored weights are allocated as necessary,
            then the tailored nodes are replaced with final CEs,
            and the CollationData is rewritten by replacing temporary CEs with final ones.
            <para/>
            We cannot simply insert new nodes in the middle of the array
            because that would invalidate the indexes stored in existing temporary CEs.
            We need to use a linked graph with stable indexes to existing nodes.
            A doubly-linked list seems easiest to maintain.
            <para/>
            Each node is stored as an long, with its fields stored as bit fields.
            <para/>
            Root primary node:
            - primary weight: 32 bits 63..32
            - reserved/unused/zero: 4 bits 31..28
            <para/>
            Weaker root nodes &amp; tailored nodes:
            - a weight: 16 bits 63..48
              + a root or default weight for a non-tailored node
              + unused/zero for a tailored node
            - index to the previous node: 20 bits 47..28
            <para/>
            All types of nodes:
            - index to the next node: 20 bits 27..8
              + nextIndex=0 in last node per root-primary list
            - reserved/unused/zero bits: bits 7, 4, 2
            - HAS_BEFORE2: bit 6
            - HAS_BEFORE3: bit 5
            - IS_TAILORED: bit 3
            - the difference strength (primary/secondary/tertiary/quaternary): 2 bits 1..0
            <para/>
            We could allocate structs with pointers, but we would have to store them
            in a pointer list so that they can be indexed from temporary CEs,
            and they would require more memory allocations.
            </remarks>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationCompare">
            <since>2012feb14</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationData">
            <summary>
            Collation data container.
            Immutable data created by a <see cref="T:ICU4N.Impl.Coll.CollationDataBuilder"/>, or loaded from a file,
            or deserialized from API-provided binary data.
            <para/>
            Includes data for the collation base (root/default), aliased if this is not the base.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetCE32FromContexts(System.Int32)">
            <summary>
            Returns the CE32 from two contexts words.
            Access to the defaultCE32 for contraction and prefix matching.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetIndirectCE32(System.Int32)">
            <summary>
            Returns the CE32 for an indirect special CE32 (e.g., with DIGIT_TAG).
            Requires that <paramref name="ce32"/> is special.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetFinalCE32(System.Int32)">
            <summary>
            Returns the CE32 for an indirect special CE32 (e.g., with DIGIT_TAG),
            if <paramref name="ce32"/> is special.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetCEFromOffsetCE32(System.Int32,System.Int32)">
            <summary>
            Computes a CE from <paramref name="c"/>'s <paramref name="ce32"/> which has the <see cref="F:ICU4N.Impl.Coll.Collation.OFFSET_TAG"/>.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetSingleCE(System.Int32)">
            <summary>
            Returns the single CE that c maps to.
            Throws <see cref="T:System.NotSupportedException"/> if <paramref name="c"/> does not map to a single CE.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetFCD16(System.Int32)">
            <summary>
            Returns the FCD16 value for code point <paramref name="c"/>. <paramref name="c"/> must be >= 0.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetFirstPrimaryForGroup(System.Int32)">
            <summary>
            Returns the first primary for the <paramref name="script"/>'s reordering group.
            </summary>
            <returns>The primary with only the first primary lead byte of the group
            (not necessarily an actual root collator primary weight),
            or 0 if the <paramref name="script"/> is unknown
            </returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetLastPrimaryForGroup(System.Int32)">
            <summary>
            Returns the last primary for the <paramref name="script"/>'s reordering group.
            </summary>
            <returns>The last primary of the group
            (not an actual root collator primary weight),
            or 0 if the <paramref name="script"/> is unknown.
            </returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.GetGroupForPrimary(System.Int64)">
            <summary>
            Finds the reordering group which contains the primary weight.
            </summary>
            <returns>The first script of the group, or -1 if the weight is beyond the last group.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationData.MakeReorderRanges(System.Int32[],System.Collections.Generic.IList{System.Int32})">
            <summary>
            Writes the permutation of primary-weight ranges
            for the given reordering of scripts and groups.
            The caller checks for illegal arguments and
            takes care of [DEFAULT] and memory allocation.
            <para/>
            Each list element will be a (limit, offset) pair as described
            for the <see cref="F:ICU4N.Impl.Coll.CollationSettings.reorderRanges"/>.
            The list will be empty if no ranges are reordered.
            </summary>
            <param name="reorder"></param>
            <param name="ranges"></param>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.JAMO_CE32S_LENGTH">
            <seealso cref="F:ICU4N.Impl.Coll.CollationData.jamoCE32s"/>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.trie">
            <summary>Main lookup trie.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.ce32s">
            <summary>
            Array of CE32 values.
            At index 0 there must be CE32(U+0000)
            to support U+0000's special-tag for NUL-termination handling.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.ces">
            <summary>Array of CE values for expansions and <see cref="F:ICU4N.Impl.Coll.Collation.OFFSET_TAG"/>.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.contexts">
            <summary>Array of prefix and contraction-suffix matching data.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.base_">
            <summary>Base collation data, or null if this data itself is a base.</summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationData.Base">
            <summary>Base collation data, or null if this data itself is a base.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.jamoCE32s">
            <summary>
            Simple array of <see cref="F:ICU4N.Impl.Coll.CollationData.JAMO_CE32S_LENGTH"/>=19+21+27 CE32s, one per canonical Jamo L/V/T.
            They are normally simple CE32s, rarely expansions.
            For fast handling of <see cref="F:ICU4N.Impl.Coll.Collation.HANGUL_TAG"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.numericPrimary">
            <summary>The single-byte primary weight (xx000000) for numeric collation.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.compressibleBytes">
            <summary>256 flags for which primary-weight lead bytes are compressible.</summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.unsafeBackwardSet">
            <summary>
            Set of code points that are unsafe for starting string comparison after an identical prefix,
            or in backwards CE iteration.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.fastLatinTable">
            <summary>
            Fast Latin table for common-Latin-text string comparisons.
            Data structure see class <see cref="T:ICU4N.Impl.Coll.CollationFastLatin"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.fastLatinTableHeader">
            <summary>
            Header portion of the <see cref="F:ICU4N.Impl.Coll.CollationData.fastLatinTable"/>.
            In C++, these are one array, and the header is skipped for mapping characters.
            In .NET, two arrays work better.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.numScripts">
            <summary>
            Data for scripts and reordering groups.
            Uses include building a reordering permutation table and
            providing script boundaries to <see cref="T:ICU4N.Text.AlphabeticIndex`1"/>.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.scriptsIndex">
            <summary>
            The length of scriptsIndex is <see cref="F:ICU4N.Impl.Coll.CollationData.numScripts"/>+16.
            It maps from a Script code or a special reorder code to an entry in <see cref="F:ICU4N.Impl.Coll.CollationData.scriptStarts"/>.
            16 special reorder codes (not all used) are mapped starting at <see cref="F:ICU4N.Impl.Coll.CollationData.numScripts"/>.
            Up to <see cref="F:ICU4N.Impl.Coll.CollationData.MAX_NUM_SPECIAL_REORDER_CODES"/> are codes for special groups like space/punct/digit.
            There are special codes at the end for reorder-reserved primary ranges.
            <para/>
            Multiple scripts may share a range and index, for example Hira &amp; Kana.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.scriptStarts">
            <summary>
            Start primary weight (top 16 bits only) for a group/script/reserved range
            indexed by <see cref="F:ICU4N.Impl.Coll.CollationData.scriptsIndex"/>.
            The first range (separators &amp; terminators) and the last range (trailing weights)
            are not reorderable, and no <see cref="F:ICU4N.Impl.Coll.CollationData.scriptsIndex"/> entry points to them.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationData.rootElements">
            <summary>
            Collation elements in the root collator.
            Used by the <see cref="T:ICU4N.Impl.Coll.CollationRootElements"/> class. The data structure is described there.
            null in a tailoring.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataBuilder">
            <summary>
            Low-level CollationData builder.
            Takes (character, CE) pairs and builds them into runtime data structures.
            Supports characters with context prefixes and contraction suffixes.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataBuilder.ICEModifier">
            Collation element modifier. Interface class for a modifier
            that changes a tailoring builder's temporary CEs to final CEs.
            Called for every non-special CE32 and every expansion CE.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.ICEModifier.ModifyCE32(System.Int32)">
            Returns a new CE to replace the non-special input CE32, or else Collation.NO_CE. 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.ICEModifier.ModifyCE(System.Int64)">
            Returns a new CE to replace the input CE, or else Collation.NO_CE. 
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.HasMappings">
            @return true if this builder has mappings (e.g., add() has been called)
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.IsAssigned(System.Int32)">
            @return true if c has CEs in this builder
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Coll.CollationDataBuilder.EncodeCEs(System.Int64[],System.Int32)" -->
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.CopyFrom(ICU4N.Impl.Coll.CollationDataBuilder,ICU4N.Impl.Coll.CollationDataBuilder.ICEModifier)">
            Copies all mappings from the src builder, with modifications.
            This builder here must not be built yet, and should be empty.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.GetCEs(ICU4N.Support.Text.ICharSequence,System.Int64[],System.Int32)">
             Looks up CEs for s and appends them to the ces array.
             Does not handle normalization: s should be in FCD form.
            
             Does not write completely ignorable CEs.
             Does not write beyond Collation.MAX_EXPANSION_LENGTH.
            
             @return incremented cesLength
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32">
             Build-time context and CE32 for a code point.
             If a code point has contextual mappings, then the default (no-context) mapping
             and all conditional mappings are stored in a singly-linked list
             of ConditionalCE32, sorted by context strings.
            
             Context strings sort by prefix length, then by prefix, then by contraction suffix.
             Context strings must be unique and in ascending order.
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.Context">
             "\0" for the first entry for any code point, with its default CE32.
            
             Otherwise one unit with the length of the prefix string,
             then the prefix string, then the contraction suffix.
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.Ce32">
            CE32 for the code point and its context.
            Can be special (e.g., for an expansion) but not contextual (prefix or contraction tag).
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.DefaultCE32">
            Default CE32 for all contexts with this same prefix.
            Initially NO_CE32. Set only while building runtime data structures,
            and only on one of the nodes of a sub-list with the same prefix.
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.BuiltCE32">
            CE32 for the built contexts.
            When fetching CEs from the builder, the contexts are built into their runtime form
            so that the normal collation implementation can process them.
            The result is cached in the list head. It is reset when the contexts are modified.
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32.Next">
            Index of the next ConditionalCE32.
            Negative for the end of the list.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationDataBuilder.CopyContractionsFromBaseCE32(System.Text.StringBuilder,System.Int32,System.Int32,ICU4N.Impl.Coll.CollationDataBuilder.ConditionalCE32)">
            Copies base contractions to a list of ConditionalCE32.
            Sets cond.next to the index of the first new item
            and returns the index of the last new item.
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataBuilder.DataBuilderCollationIterator">
             Build-time collation element and character iterator.
             Uses the runtime CollationIterator for fetching CEs for a string
             but reads from the builder's unfinished data structures.
             In particular, this class reads from the unfinished trie
             and has to avoid CollationIterator.nextCE() and redirect other
             calls to data.getCE32() and data.getCE32FromSupplementary().
            
             We do this so that we need not implement the collation algorithm
             again for the builder and make it behave exactly like the runtime code.
             That would be more difficult to test and maintain than this indirection.
            
             Some CE32 tags (for example, the DIGIT_TAG) do not occur in the builder data,
             so the data accesses from those code paths need not be modified.
            
             This class iterates directly over whole code points
             so that the CollationIterator does not need the finished trie
             for handling the LEAD_SURROGATE_TAG.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataBuilder.IS_BUILDER_JAMO_CE32">
            @see Collation.BUILDER_DATA_TAG 
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationDataReader">
            <summary>
            Collation binary data reader.
            </summary>
            <since>2013feb07</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_INDEXES_LENGTH">
             Number of int indexes.
            
             Can be 2 if there are only options.
             Can be 7 or 8 if there are only options and a script reordering.
             The loader treats any index>=indexes[IX_INDEXES_LENGTH] as 0.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_OPTIONS">
            Bits 31..24: numericPrimary, for numeric collation
                 23..16: fast Latin format version (0 = no fast Latin table)
                 15.. 0: options bit set
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.Coll.CollationDataReader.IX_JAMO_CE32S_START" -->
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_REORDER_CODES_OFFSET">
            Byte offset to int reorderCodes[]. 
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.Coll.CollationDataReader.IX_REORDER_TABLE_OFFSET" -->
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_TRIE_OFFSET">
            Byte offset to the collation trie. Its length is a multiple of 8 bytes. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_CES_OFFSET">
            Byte offset to long ces[]. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_CE32S_OFFSET">
            Byte offset to int ce32s[]. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_ROOT_ELEMENTS_OFFSET">
            Byte offset to uint32_t rootElements[]. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_CONTEXTS_OFFSET">
            Byte offset to UChar *contexts[]. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_UNSAFE_BWD_OFFSET">
            Byte offset to char [] with serialized unsafeBackwardSet. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_FAST_LATIN_TABLE_OFFSET">
            Byte offset to char fastLatinTable[]. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationDataReader.IX_SCRIPTS_OFFSET">
            Byte offset to char scripts[]. 
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.Coll.CollationDataReader.IX_COMPRESSIBLE_BYTES_OFFSET" -->
        <member name="T:ICU4N.Impl.Coll.CollationFastLatin">
            <since>2013aug09</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.VERSION">
             Fast Latin format version (one byte 1..FF).
             Must be incremented for any runtime-incompatible changes,
             in particular, for changes to any of the following constants.
            
             When the major version number of the main data format changes,
             we can reset this fast Latin version to 1.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.CONTRACTION">
             Contraction with one fast Latin character.
             Use INDEX_MASK to find the start of the contraction list after the fixed table.
             The first entry contains the default mapping.
             Otherwise use CONTR_CHAR_MASK for the contraction character index
             (in ascending order).
             Use CONTR_LENGTH_SHIFT for the length of the entry
             (1=BAIL_OUT, 2=one CE, 3=two CEs).
            
             Also, U+0000 maps to a contraction entry, so that the fast path need not
             check for NUL termination.
             It usually maps to a contraction list with only the completely ignorable default value.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.EXPANSION">
             An expansion encodes two CEs.
             Use INDEX_MASK to find the pair of CEs after the fixed table.
            
             The higher a mini CE value, the easier it is to process.
             For expansions and higher, no context needs to be considered.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.MIN_LONG">
            Encodes one CE with a long/low mini primary (there are 128).
            All potentially-variable primaries must be in this range,
            to make the short-primary path as fast as possible.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.MIN_SHORT">
            Encodes one CE with a short/high primary (there are 60),
            plus a secondary CE if the secondary weight is high.
            Fast handling: At least all letter primaries should be in this range.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.MAX_SHORT">
            The highest primary weight is reserved for U+FFFF. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.SEC_OFFSET">
            Lookup: Add this offset to secondary weights, except for completely ignorable CEs.
            Must be greater than any special value, e.g., MERGE_WEIGHT.
            The exact value is not relevant for the format version.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.TER_OFFSET">
            Lookup: Add this offset to tertiary weights, except for completely ignorable CEs.
            Must be greater than any special value, e.g., MERGE_WEIGHT.
            Must be greater than case bits as well, so that with combined case+tertiary weights
            plus the offset the tertiary bits does not spill over into the case bits.
            The exact value is not relevant for the format version.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.CONTR_CHAR_MASK">
            Contraction result first word bits 8..0 contain the
            second contraction character, as a char index 0..NUM_FAST_CHARS-1.
            Each contraction list is terminated with a word containing CONTR_CHAR_MASK.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.CONTR_LENGTH_SHIFT">
            Contraction result first word bits 10..9 contain the result length:
            1=bail out, 2=one mini CE, 3=two mini CEs
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationFastLatin.BAIL_OUT_RESULT">
            Comparison return value when the regular comparison must be used.
            The exact value is not relevant for the format version.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFastLatin.GetOptions(ICU4N.Impl.Coll.CollationData,ICU4N.Impl.Coll.CollationSettings,System.Char[])">
            Computes the options value for the compare functions
            and writes the precomputed primary weights.
            Returns -1 if the Latin fastpath is not supported for the data and settings.
            The capacity must be LATIN_LIMIT.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFastLatin.NextPair(System.Char[],System.Int32,System.Int32,ICU4N.Support.Text.ICharSequence,System.Int32)">
            Java returns a negative result (use the '~' operator) if sIndex is to be incremented.
            C++ modifies sIndex.
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationFastLatinBuilder">
            <since>2013aug09</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFastLatinBuilder.CompareInt64AsUnsigned(System.Int64,System.Int64)">
            Compare two signed long values as if they were unsigned.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Coll.CollationFastLatinBuilder.BinarySearch(System.Collections.Generic.IList{System.Int64},System.Int32,System.Int64)" -->
        <member name="F:ICU4N.Impl.Coll.CollationFastLatinBuilder.miniCEs">
            One 16-bit mini CE per unique CE. 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFCD.MaybeTibetanCompositeVowel(System.Int32)">
             Tibetan composite vowel signs (U+0F73, U+0F75, U+0F81)
             must be decomposed before reaching the core collation code,
             or else some sequences including them, even ones passing the FCD check,
             do not yield canonically equivalent results.
            
             This is a fast and imprecise test.
            
             @param c a code point
             @return true if c is U+0F73, U+0F75 or U+0F81 or one of several other Tibetan characters
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationFCD.IsFCD16OfTibetanCompositeVowel(System.Int32)">
             Tibetan composite vowel signs (U+0F73, U+0F75, U+0F81)
             must be decomposed before reaching the core collation code,
             or else some sequences including them, even ones passing the FCD check,
             do not yield canonically equivalent results.
            
             They have distinct lccc/tccc combinations: 129/130 or 129/132.
            
             @param fcd16 the FCD value (lccc/tccc combination) of a code point
             @return true if fcd16 is from U+0F73, U+0F75 or U+0F81
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationIterator.CEBuffer.INITIAL_CAPACITY">
            Large enough for CEs of most short strings. 
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Coll.CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)" -->
        <member name="M:ICU4N.Impl.Coll.CollationIterator.ResetToOffset(System.Int32)">
            Resets the iterator state and sets the position to the specified offset.
            Subclasses must implement, and must call the parent class method,
            or CollationIterator.reset().
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.NextCE">
            Returns the next collation element.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.FetchCEs">
            Fetches all CEs.
            @return getCEsLength()
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.SetCurrentCE(System.Int64)">
            Overwrites the current CE (the last one returned by nextCE()).
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.PreviousCE(System.Collections.Generic.IList{System.Int32})">
            Returns the previous collation element.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.NextCodePoint">
            Returns the next code point (with post-increment).
            Public for identical-level comparison and for testing.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.PreviousCodePoint">
            Returns the previous code point (with pre-decrement).
            Public for identical-level comparison and for testing.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.Reset(System.Boolean)">
            Resets the state as well as the numeric setting,
            and completes the initialization.
            Only exists in Java where we reset cached CollationIterator instances
            rather than stack-allocating temporary ones.
            (See also the constructor comments.)
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.HandleNextCE32">
             Returns the next code point and its local CE32 value.
             Returns Collation.FALLBACK_CE32 at the end of the text (c&lt;0)
             or when c's CE32 value is to be looked up in the base data (fallback).
            
             The code point is used for fallbacks, context and implicit weights.
             It is ignored when the returned CE32 is not special (e.g., FFFD_CE32).
            
             Returns the code point in bits 63..32 (signed) and the CE32 in bits 31..0.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.HandleGetTrailSurrogate">
            Called when handleNextCE32() returns a LEAD_SURROGATE_TAG for a lead surrogate code unit.
            Returns the trail surrogate in that case and advances past it,
            if a trail surrogate follows the lead surrogate.
            Otherwise returns any other code unit and does not advance.
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationIterator.ForbidSurrogateCodePoints">
            @return false if surrogate code points U+D800..U+DFFF
                    map to their own implicit primary weights (for UTF-16),
                    or true if they map to CE(U+FFFD) (for UTF-8)
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.GetDataCE32(System.Int32)">
            Returns the CE32 from the data trie.
            Normally the same as data.getCE32(), but overridden in the builder.
            Call this only when the faster data.getCE32() cannot be used.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.PreviousCEUnsafe(System.Int32,System.Collections.Generic.IList{System.Int32})">
            Returns the previous CE when data.isUnsafeBackward(c, isNumeric).
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.AppendNumericCEs(System.Int32,System.Boolean)">
             Turns a string of digits (bytes 0..9)
             into a sequence of CEs that will sort in numeric order.
            
             Starts from this ce32's digit value and consumes the following/preceding digits.
             The digits string must not be empty and must not have leading zeros.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationIterator.AppendNumericSegmentCEs(ICU4N.Support.Text.ICharSequence)">
            Turns 1..254 digits into a sequence of CEs.
            Called by appendNumericCEs() for each segment of at most 254 digits.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationKeys.SortKeyByteSink.SetBufferAndAppended(System.Byte[],System.Int32)">
            Needed in Java for when we write to the buffer directly.
            In C++, the SortKeyByteSink is a subclass of ByteSink and lower-level code can write to that.
            TODO: Can we make Java SortKeyByteSink have-a ByteArrayWrapper and write through to it?
            Or maybe create interface ByteSink, have SortKeyByteSink implement it, and have BOCSU write to that??
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationKeys.SortKeyByteSink.Append(System.Byte[],System.Int32)">
            @param bytes
                       the array of byte
            @param n
                       the length of bytes to be appended
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationKeys.SortKeyByteSink.AppendBeyondCapacity(System.Byte[],System.Int32,System.Int32,System.Int32)">
            @param bytes
                       the array of byte
            @param start
                       the start index within the array to be appended
            @param n
                       the length of bytes to be appended
            @param length
                       the length of buffer required to store the entire data (i.e. already appended
                       bytes + bytes to be appended by this method)
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationKeys.LevelCallback.NeedToWrite(System.Int32)">
            @param level
                       The next level about to be written to the ByteSink.
            @return true if the level is to be written (the base class implementation always returns
                    true)
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationKeys.levelMasks">
            Map from collation strength (UColAttributeValue) to a mask of Collation.Level bits up to that
            strength, excluding the CASE_LEVEL which is independent of the strength, and excluding
            IDENTICAL_LEVEL which this function does not write.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationKeys.WriteSortKeyUpToQuaternary(ICU4N.Impl.Coll.CollationIterator,System.Boolean[],ICU4N.Impl.Coll.CollationSettings,ICU4N.Impl.Coll.CollationKeys.SortKeyByteSink,System.Int32,ICU4N.Impl.Coll.CollationKeys.LevelCallback,System.Boolean)">
            Writes the sort key bytes for minLevel up to the iterator data's strength. Optionally writes
            the case level. Stops writing levels when callback.needToWrite(level) returns false.
            Separates levels with the LEVEL_SEPARATOR_BYTE but does not write a TERMINATOR_BYTE.
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationLoader">
            <summary>
            Convenience string denoting the Collation data tree
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationLoader.ASCII">
            Simpler/faster methods for ASCII than ones based on Unicode data.
            TODO: There should be code like this somewhere already??
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationRoot">
            <summary>
            Collation root provider.
            </summary>
            <since>2012dec17</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationRootElements">
            <summary>
            Container and access methods for collation elements and weights
            that occur in the root collator.
            Needed for finding boundaries for building a tailoring.
            <para/>
            This class takes and returns 16-bit secondary and tertiary weights.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.PRIMARY_SENTINEL">
            <summary>
            Higher than any root primary.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.SEC_TER_DELTA_FLAG">
            <summary>
            Flag in a root element, set if the element contains secondary &amp; tertiary weights,
            rather than a primary.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.PRIMARY_STEP_MASK">
            <summary>
            Mask for getting the primary range step value from a primary-range-end element.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_FIRST_TERTIARY_INDEX">
            <summary>
            Index of the first CE with a non-zero tertiary weight.
            Same as the start of the compact root elements table.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_FIRST_SECONDARY_INDEX">
            <summary>
            Index of the first CE with a non-zero secondary weight.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_FIRST_PRIMARY_INDEX">
            <summary>
            Index of the first CE with a non-zero primary weight.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_COMMON_SEC_AND_TER_CE">
            <summary>
            Must match Collation.COMMON_SEC_AND_TER_CE.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_SEC_TER_BOUNDARIES">
            <summary>
            Secondary &amp; tertiary boundaries.
            Bits 31..24: [fixed last secondary common byte 45]
            Bits 23..16: [fixed first ignorable secondary byte 80]
            Bits 15.. 8: reserved, 0
            Bits  7.. 0: [fixed first ignorable tertiary byte 3C]
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.IX_COUNT">
            <summary>
            The current number of indexes.
            Currently the same as elements[IX_FIRST_TERTIARY_INDEX].
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.TertiaryBoundary">
            <summary>
            Gets the boundary between tertiary weights of primary/secondary CEs
            and those of tertiary CEs.
            This is the upper limit for tertiaries of primary/secondary CEs.
            This minus one is the lower limit for tertiaries of tertiary CEs.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.FirstTertiaryCE">
            <summary>
            Gets the first assigned tertiary CE.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.LastTertiaryCE">
            <summary>
            Gets the last assigned tertiary CE.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.LastCommonSecondary">
            <summary>
            Gets the last common secondary weight.
            This is the lower limit for secondaries of primary CEs.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.SecondaryBoundary">
            <summary>
            Gets the boundary between secondary weights of primary CEs
            and those of secondary CEs.
            This is the upper limit for secondaries of primary CEs.
            This minus one is the lower limit for secondaries of secondary CEs.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.FirstSecondaryCE">
            <summary>
            Gets the first assigned secondary CE.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.LastSecondaryCE">
            <summary>
            Gets the last assigned secondary CE.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.FirstPrimary">
            <summary>
            Gets the first assigned primary weight.
            </summary>
        </member>
        <member name="P:ICU4N.Impl.Coll.CollationRootElements.FirstPrimaryCE">
            <summary>
            Gets the first assigned primary CE.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.LastCEWithPrimaryBefore(System.Int64)">
            <summary>
            Returns the last root CE with a primary weight before <paramref name="p"/>.
            Intended only for reordering group boundaries.
            </summary>
            <param name="p"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.FirstCEWithPrimaryAtLeast(System.Int64)">
            <summary>
            Returns the first root CE with a primary weight of at least <paramref name="p"/>.
            Intended only for reordering group boundaries.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetPrimaryBefore(System.Int64,System.Boolean)">
            <summary>
            Returns the primary weight before <paramref name="p"/>.
            <paramref name="p"/> must be greater than the first root primary.
            </summary>
            <param name="p"></param>
            <param name="isCompressible"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetSecondaryBefore(System.Int64,System.Int32)">
            <summary>Returns the secondary weight before [p, s].</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetTertiaryBefore(System.Int64,System.Int32,System.Int32)">
            <summary>Returns the tertiary weight before [p, s, t].</summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.FindPrimary(System.Int64)">
            <summary>
            Finds the index of the input primary.
            <paramref name="p"/> must occur as a root primary, and must not be 0.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetPrimaryAfter(System.Int64,System.Int32,System.Boolean)">
            <summary>
            Returns the primary weight after <paramref name="p"/> where index=FindPrimary(p).
            <paramref name="p"/> must be at least the first root primary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetSecondaryAfter(System.Int32,System.Int32)">
            <summary>
            Returns the secondary weight after [p, s] where index=FindPrimary(p)
            except use index=0 for p=0.
            <para/>
            Must return a weight for every root [p, s] as well as for every weight
            returned by GetSecondaryBefore(). If p!=0 then s can be BEFORE_WEIGHT16.
            <para/>
            Exception: [0, 0] is handled by the CollationBuilder:
            Both its lower and upper boundaries are special.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetTertiaryAfter(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the tertiary weight after [p, s, t] where index=FindPrimary(p)
            except use index=0 for p=0.
            <para/>
            Must return a weight for every root [p, s, t] as well as for every weight
            returned by GetTertiaryBefore(). If s!=0 then t can be BEFORE_WEIGHT16.
            <para/>
            Exception: [0, 0, 0] is handled by the CollationBuilder:
            Both its lower and upper boundaries are special.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.GetFirstSecTerForPrimary(System.Int32)">
            <summary>
            Returns the first secondary &amp; tertiary weights for p where index=findPrimary(p)+1.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRootElements.FindP(System.Int64)">
            <summary>
            Finds the largest index i where elements[i]&lt;=p.
            Requires first primary&lt;=p&lt;0xffffff00 (PRIMARY_SENTINEL).
            Does not require that p is a root collator primary.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRootElements.elements">
            <summary>
            Data structure: See ICU4C source/i18n/collationrootelements.h.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationRuleParser.Position">
            Special reset positions. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRuleParser.POS_LEAD">
             First character of contractions that encode special reset positions.
             U+FFFE cannot be tailored via rule syntax.
            
             The second contraction character is POS_BASE + Position.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRuleParser.POS_BASE">
            Base for the second character of contractions that encode special reset positions.
            Braille characters U+28xx are printable and normalization-inert.
            @see POS_LEAD
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Coll.CollationRuleParser.Sink.AddReset(ICU4N.Text.CollationStrength,ICU4N.Support.Text.ICharSequence)" -->
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.Sink.AddRelation(ICU4N.Text.CollationStrength,ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence,System.String)">
            Adds a relation with strength and prefix | str / extension.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.#ctor(ICU4N.Impl.Coll.CollationData)">
            Constructor.
            The Sink must be set before parsing.
            The Importer can be set, otherwise [import locale] syntax is not supported.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.SetSink(ICU4N.Impl.Coll.CollationRuleParser.Sink)">
            Sets the pointer to a Sink object.
            The pointer is aliased: Pointer copy without cloning or taking ownership.
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.SetImporter(ICU4N.Impl.Coll.CollationRuleParser.IImporter)">
            Sets the pointer to an Importer object.
            The pointer is aliased: Pointer copy without cloning or taking ownership.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationRuleParser.STRENGTH_MASK">
            UCOL_PRIMARY=0 .. UCOL_IDENTICAL=15 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.ParseSpecialPosition(System.Int32,System.Text.StringBuilder)">
            Sets str to a contraction of U+FFFE and (U+2800 + Position).
            @return rule index after the special reset position
            @throws ParseException 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.GetReorderCode(System.String)">
            Gets a script or reorder code from its string representation.
            @return the script/reorder code, or
            -1 if not recognized
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationRuleParser.IsSyntaxChar(System.Int32)">
            ASCII [:P:] and [:S:]:
            [\u0021-\u002F \u003A-\u0040 \u005B-\u0060 \u007B-\u007E]
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.CHECK_FCD">
            Options bit 0: Perform the FCD check on the input text and deliver normalized text.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.NUMERIC">
             Options bit 1: Numeric collation.
             Also known as CODAN = COllate Digits As Numbers.
            
             Treat digit sequences as numbers with CE sequences in numeric order,
             rather than returning a normal CE for each digit.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.SHIFTED">
            "Shifted" alternate handling, see ALTERNATE_MASK.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.ALTERNATE_MASK">
            Options bits 3..2: Alternate-handling mask. 0 for non-ignorable.
            Reserve values 8 and 0xc for shift-trimmed and blanked.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.MAX_VARIABLE_SHIFT">
            Options bits 6..4: The 3-bit maxVariable value bit field is shifted by this value.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.MAX_VARIABLE_MASK">
            maxVariable options bit mask before shifting. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.UPPER_FIRST">
            Options bit 7: Reserved/unused/0. 
            Options bit 8: Sort uppercase first if caseLevel or caseFirst is on.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.CASE_FIRST">
             Options bit 9: Keep the case bits in the tertiary weight (they trump other tertiary values)
             unless case level is on (when they are *moved* into the separate case level).
             By default, the case bits are removed from the tertiary weight (ignored).
            
             When CASE_FIRST is off, UPPER_FIRST must be off too, corresponding to
             the tri-value UCOL_CASE_FIRST attribute: UCOL_OFF vs. UCOL_LOWER_FIRST vs. UCOL_UPPER_FIRST.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.CASE_FIRST_AND_UPPER_MASK">
            Options bit mask for caseFirst and upperFirst, before shifting.
            Same value as caseFirst==upperFirst.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.CASE_LEVEL">
            Options bit 10: Insert the case level between the secondary and tertiary levels.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.BACKWARD_SECONDARY">
            Options bit 11: Compare secondary weights backwards. ("French secondary")
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.STRENGTH_SHIFT">
            Options bits 15..12: The 4-bit strength value bit field is shifted by this value.
            It is the top used bit field in the options. (No need to mask after shifting.)
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.STRENGTH_MASK">
            Strength options bit mask before shifting. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.MAX_VAR_SPACE">
            maxVariable values 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationSettings.SetFlag(System.Int32,System.Boolean)">
            Sets the options bit for an on/off attribute. 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationSettings.IsTertiaryWithCaseBits(System.Int32)">
            Include case bits in the tertiary level if caseLevel=off and caseFirst!=off.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.options">
            CHECK_FCD etc. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.variableTop">
            Variable-top primary weight. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.reorderTable">
            256-byte table for reordering permutation of primary lead bytes; null if no reordering.
            A 0 entry at a non-zero index means that the primary lead byte is "split"
            (there are different offsets for primaries that share that lead byte)
            and the reordering offset must be determined via the reorderRanges.
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.minHighNoReorder">
            Limit of last reordered range. 0 if no reordering or no split bytes. 
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Impl.Coll.CollationSettings.reorderRanges" -->
        <member name="F:ICU4N.Impl.Coll.CollationSettings.reorderCodes">
            Array of reorder codes; ignored if length == 0. 
        </member>
        <member name="F:ICU4N.Impl.Coll.CollationSettings.fastLatinOptions">
            Options for CollationFastLatin. Negative if disabled. 
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationTailoring">
            <summary>
            Collation tailoring data &amp; settings.
            This is a container of values for a collation tailoring
            built from rules or deserialized from binary data.
            <para/>
            It is logically immutable: Do not modify its values.
            The fields are public for convenience.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationTailoring.SetRules(System.String)">
            Not thread-safe, call only before sharing. 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationTailoring.SetRulesResource(ICU4N.Util.UResourceBundle)">
            Not thread-safe, call only before sharing. 
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationWeights">
            <summary>
            Allocates n collation element weights between two exclusive limits.
            Used only internally by the collation tailoring builder.
            </summary>
            <since>2001mar08</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationWeights.AllocWeights(System.Int64,System.Int64,System.Int32)">
             Determine heuristically
             what ranges to use for a given number of weights between (excluding)
             two limits.
            
             @param lowerLimit A collation element weight; the ranges will be filled to cover
                               weights greater than this one.
             @param upperLimit A collation element weight; the ranges will be filled to cover
                               weights less than this one.
             @param n          The number of collation element weights w necessary such that
                               lowerLimit&lt;w&lt;upperLimit in lexical order.
             @return true if it is possible to fit n elements between the limits
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationWeights.NextWeight">
             Given a set of ranges calculated by allocWeights(),
             iterate through the weights.
             The ranges are modified to keep the current iteration state.
            
             @return The next weight in the ranges, or 0xffffffff if there is none left.
        </member>
        <member name="T:ICU4N.Impl.Coll.CollationWeights.WeightRange">
            @internal 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationWeights.CountBytes(System.Int32)">
            @return number of usable byte values for byte idx 
        </member>
        <member name="M:ICU4N.Impl.Coll.CollationWeights.GetWeightRanges(System.Int64,System.Int64)">
            Takes two CE weights and calculates the
            possible ranges of weights between the two limits, excluding them.
            For weights with up to 4 bytes there are up to 2*4-1=7 ranges.
        </member>
        <member name="T:ICU4N.Impl.Coll.ContractionsAndExpansions">
            <since>2013feb09</since>
            <author>Markus W. Scherer</author>
        </member>
        <member name="T:ICU4N.Impl.Coll.FCDIterCollationIterator">
            <summary>
            Incrementally checks the input text for FCD and normalizes where necessary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDIterCollationIterator.SwitchToForward">
            Switches to forward checking if possible.
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDIterCollationIterator.NextSegment">
            <summary>
            Extends the FCD text segment forward or normalizes around pos.
            </summary>
            <returns><c>true</c> if success.</returns>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDIterCollationIterator.SwitchToBackward">
            <summary>
            Switches to backward checking.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDIterCollationIterator.PreviousSegment">
            <summary>
            Extends the FCD text segment backward or normalizes around pos.
            </summary>
            <returns><c>true</c> if success.</returns>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.IterCheckFwd">
            <summary>
            The input text [start..(iter index)[ passes the FCD check.
            Moving forward checks incrementally.
            pos &amp; limit are undefined.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.IterCheckBwd">
            <summary>
            The input text [(iter index)..limit[ passes the FCD check.
            Moving backward checks incrementally.
            start &amp; pos are undefined.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.IterInFCDSegment">
            <summary>
            The input text [start..limit[ passes the FCD check.
            pos tracks the current text index.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.InNormIterAtLimit">
            <summary>
            The input text [start..limit[ failed the FCD check and was normalized.
            pos tracks the current index in the normalized string.
            The text iterator is at the limit index.
            </summary>
        </member>
        <member name="F:ICU4N.Impl.Coll.FCDIterCollationIterator.State.InNormIterAtStart">
            <summary>
            The input text [start..limit[ failed the FCD check and was normalized.
            pos tracks the current index in the normalized string.
            The text iterator is at the start index.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.FCDUTF16CollationIterator">
            <summary>
            Incrementally checks the input text for FCD and normalizes where necessary.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)">
            <summary>
            Partial constructor, see <see cref="M:ICU4N.Impl.Coll.CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.SwitchToForward" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.NextSegment" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.SwitchToBackward" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Impl.Coll.FCDUTF16CollationIterator.PreviousSegment" -->
        <member name="T:ICU4N.Impl.Coll.IterCollationIterator">
            <summary>
            <see cref="T:ICU4N.Text.UCharacterIterator"/>-based collation element and character iterator.
            Handles normalized text, with length or NUL-terminated.
            Unnormalized text is handled by a subclass.
            </summary>
        </member>
        <member name="T:ICU4N.Impl.Coll.SharedObject.Reference`1">
            Similar to a smart pointer, basically a port of the static methods of C++ SharedObject.
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.Reference`1.CopyOnWrite">
            Returns a writable version of the reference.
            If there is exactly one owner, then the reference itself is returned.
            If there are multiple owners, then the reference is replaced with a clone,
            and that is returned.
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.#ctor">
            Initializes refCount to 0. 
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.Clone">
            Initializes refCount to 0. 
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.AddRef">
            Increments the number of references to this object. Thread-safe.
        </member>
        <member name="M:ICU4N.Impl.Coll.SharedObject.RemoveRef">
            Decrements the number of references to this object,
            and auto-deletes "this" if the number becomes 0. Thread-safe.
        </member>
        <member name="P:ICU4N.Impl.Coll.SharedObject.RefCount">
            Returns the reference counter. Uses a memory barrier.
        </member>
        <member name="T:ICU4N.Impl.Coll.UTF16CollationIterator">
            <summary>
            UTF-16 collation element and character iterator.
            Handles normalized UTF-16 text, with length or NUL-terminated.
            Unnormalized text is handled by a subclass.
            </summary>
        </member>
        <member name="M:ICU4N.Impl.Coll.UTF16CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)">
            <summary>
            Partial constructor, see <see cref="M:ICU4N.Impl.Coll.CollationIterator.#ctor(ICU4N.Impl.Coll.CollationData)"/>
            </summary>
        </member>
        <member name="T:ICU4N.Text.AlphabeticIndex`1">
            <summary>
            <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> supports the creation of a UI index appropriate for a given language.
            It can support either direct use, or use with a client that doesn't support localized collation.
            </summary>
            <remarks>
            The following is an example of what an index might look like in a UI:
            <code>
             <b>... A B C D E F G H I J K L M N O P Q R S T U V W X Y Z  ...</b>
             
             <b>A</b>
                Addison
                Albertson
                Azensky
             <b>B</b>
                Baecker
             ...
            </code>
            <para/>
            The class can generate a list of labels for use as a UI "index", that is, a list of
            clickable characters (or character sequences) that allow the user to see a segment
            (bucket) of a larger "target" list. That is, each label corresponds to a bucket in
            the target list, where everything in the bucket is greater than or equal to the character
            (according to the locale's collation). Strings can be added to the index;
            they will be in sorted order in the right bucket.
            <para/>
            The class also supports having buckets for strings before the first (underflow),
            after the last (overflow), and between scripts (inflow). For example, if the index
            is constructed with labels for Russian and English, Greek characters would fall
            into an inflow bucket between the other two scripts.
            <para/>
            <em>Note:</em> If you expect to have a lot of ASCII or Latin characters
            as well as characters from the user's language,
            then it is a good idea to call <see cref="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(ICU4N.Util.ULocale[])"/> with <see cref="F:ICU4N.Util.ULocale.ENGLISH"/>.
            <h2>Direct Use</h2>
            The following shows an example of building an index directly.
            The "show..." methods below are just to illustrate usage.
            <code>
            // Create a simple index where the values for the strings are Integers, and add the strings
            
            AlphabeticIndex&lt;int&gt; index = new AlphabeticIndex&lt;int&gt;(desiredLocale).AddLabels(additionalLocale);
            int counter = 0;
            foreach (string item in test)
            {
                index.AddRecord(item, counter++);
            }
            ...
            // Show index at top. We could skip or gray out empty buckets
            
            foreach (AlphabeticIndex&lt;int&gt;.Bucket bucket in index)
            {
                if (showAll || bucket.Count != 0)
                {
                    ShowLabelAtTop(UI, bucket.Label);
                }
            }
            ...
            // Show the buckets with their contents, skipping empty buckets
            
            foreach (AlphabeticIndex&lt;int&gt;.Bucket bucket in index)
            {
                if (bucket.Count != 0)
                {
                    ShowLabelInList(UI, bucket.Label);
                    foreach (AlphabeticIndex&lt;int&gt;.Record item in bucket)
                    {
                        ShowIndexedItem(UI, item.Name, item.Data);
                    }
                }
            }
            </code>
            The caller can build different UIs using this class.
            For example, an index character could be omitted or grayed-out
            if its bucket is empty. Small buckets could also be combined based on size, such as:
            <code>
            <b>... A-F G-N O-Z ...</b>
            </code>
            <h2>Client Support</h2>
            Callers can also use the <see cref="T:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex"/>, or the <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> itself,
            to support sorting on a client that doesn't support <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> functionality.
            <para/>
            The <see cref="T:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex"/> is both immutable and thread-safe.
            The corresponding <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> methods are not thread-safe because
            they "lazily" build the index buckets.
            <list type="bullet">
                <item><description>
                    <see cref="M:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex.GetBucket(System.Int32)"/> provides random access to all
                    buckets and their labels and label types.
                </description></item>
                <item><description>
                    <see cref="M:ICU4N.Text.AlphabeticIndex`1.GetBucketLabels"/> or the bucket iterator on either class
                    can be used to get a list of the labels,
                    such as "...", "A", "B",..., and send that list to the client.
                </description></item>
                <item><description>
                    When the client has a new name, it sends that name to the server.
                    The server needs to call the following methods,
                    and communicate the bucketIndex and collationKey back to the client.
                    
                    <code>
                    int bucketIndex = index.GetBucketIndex(name);
                    string label = immutableIndex.GetBucket(bucketIndex).Label;  // optional
                    RawCollationKey collationKey = collator.GetRawCollationKey(name, null);
                    </code>
                    
                </description></item>
                <item><description>
                    The client would put the name (and associated information) into its bucket for bucketIndex. The collationKey is a
                    sequence of bytes that can be compared with a binary compare, and produce the right localized result.
                </description></item>
            </list>
            </remarks>
            <typeparam name="T">Data type of bucket data.</typeparam>
            <author>Mark Davis</author>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.AlphabeticIndex`1.BASE">
            <summary>
            Prefix string for Chinese index buckets.
            See http://unicode.org/repos/cldr/trunk/specs/ldml/tr35-collation.html#Collation_Indexes
            </summary>
        </member>
        <member name="T:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex">
            <summary>
            Immutable, thread-safe version of <see cref="T:ICU4N.Text.AlphabeticIndex`1"/>.
            This class provides thread-safe methods for bucketing,
            and random access to buckets and their properties,
            but does not offer adding records to the index.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex.BucketCount">
            <summary>
            Gets the number of index buckets and labels, including underflow/inflow/overflow.
            </summary>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex.GetBucketIndex(System.String)">
            <summary>
            Finds the index bucket for the given name and returns the number of that bucket.
            Use <see cref="M:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex.GetBucket(System.Int32)"/> to get the bucket's properties.
            </summary>
            <param name="name">The string to be sorted into an index bucket.</param>
            <returns>The bucket number for the name.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex.GetBucket(System.Int32)">
            <summary>
            Returns the <paramref name="index"/>-th bucket. Returns null if the index is out of range.
            </summary>
            <param name="index">Bucket number.</param>
            <returns>The <paramref name="index"/>-th bucket.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.#ctor(ICU4N.Util.ULocale)">
            <summary>
            Create the index object.
            </summary>
            <param name="locale">The locale for the index.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.#ctor(System.Globalization.CultureInfo)">
            <summary>
            Create the index object.
            </summary>
            <param name="locale">The locale for the index.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.#ctor(ICU4N.Text.RuleBasedCollator)">
            <summary>
            Create an <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> that uses a specific collator.
            <para/>
            The index will be created with no labels; the <see cref="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(System.Globalization.CultureInfo[])"/> function (or overload) must be called
            after creation to add the desired labels to the index.
            <para/>
            The index will work directly with the supplied collator. If the caller will need to
            continue working with the collator it should be cloned first, so that the
            collator provided to the <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> remains unchanged after creation of the index.
            </summary>
            <param name="collator">The collator to use to order the contents of this index.</param>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.#ctor(ICU4N.Util.ULocale,ICU4N.Text.RuleBasedCollator)">
            <summary>
            Internal constructor containing implementation used by public constructors.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(ICU4N.Text.UnicodeSet)">
            <summary>
            Add more index characters (aside from what are in the locale)
            </summary>
            <param name="additions">Additional characters to add to the index, such as A-Z.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(ICU4N.Util.ULocale[])">
            <summary>
            Add more index characters (aside from what are in the locale)
            </summary>
            <param name="additions">Additional characters to add to the index, such as those in Swedish.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddLabels(System.Globalization.CultureInfo[])">
            <summary>
            Add more index characters (aside from what are in the locale)
            </summary>
            <param name="additions">Additional characters to add to the index, such as those in Swedish.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.SetOverflowLabel(System.String)">
            <summary>
            Set the overflow label.
            </summary>
            <param name="overflowLabel">See <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> class description.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.UnderflowLabel">
            <summary>
            Get the default label used in the IndexCharacters' locale for underflow, eg the last item in: X Y Z ...
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.SetUnderflowLabel(System.String)">
            <summary>
            Set the underflowLabel label.
            </summary>
            <param name="underflowLabel">See <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> class description.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.OverflowLabel">
            <summary>
            Get the default label used in the IndexCharacters' locale for overflow, eg the first item in: ... A B C
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.SetInflowLabel(System.String)">
            <summary>
            Set the inflowLabel label.
            </summary>
            <param name="inflowLabel">See <see cref="T:ICU4N.Text.AlphabeticIndex`1"/> class description.</param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.InflowLabel">
            <summary>
            Get the default label used for abbreviated buckets <i>between</i> other labels. For example, consider the labels
            for Latin and Greek are used: X Y Z ... &#x0391; &#x0392; &#x0393;.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.MaxLabelCount">
            <summary>
            Get the limit on the number of labels in the index. The number of buckets can be slightly larger: see <see cref="P:ICU4N.Text.AlphabeticIndex`1.BucketCount"/>.
            Returns maximum number of labels.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.SetMaxLabelCount(System.Int32)">
            <summary>
            Set a limit on the number of labels in the index. The number of buckets can be slightly larger: see
            <see cref="P:ICU4N.Text.AlphabeticIndex`1.BucketCount"/>.
            </summary>
            <param name="maxLabelCount">
            Set the maximum number of labels. Currently, if the number is exceeded, then every
            nth item is removed to bring the count down. A more sophisticated mechanism may be available in the
            future.
            </param>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.InitLabels">
            <summary>
            Determine the best labels to use. This is based on the exemplars, but we also process to make sure that they are unique,
            and sort differently, and that the overall list is small enough.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddIndexExemplars(ICU4N.Util.ULocale)">
            <summary>
            This method is called to get the index exemplars. Normally these come from the <paramref name="locale"/> directly,
            but if they aren't available, we have to synthesize them.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddChineseIndexCharacters">
            <summary>
            Add Chinese index characters from the tailoring.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.Separated(System.String)">
            <summary>
            Return the string with interspersed CGJs. Input must have more than 2 codepoints.
            <para/>
            This is used to test whether contractions sort differently from their components.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.BuildImmutableIndex">
            <summary>
            Builds an immutable, thread-safe version of this instance, without data records.
            </summary>
            <returns>An immutable index instance.</returns>
            <stable>ICU 51</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.GetBucketLabels">
            <summary>
            Get the labels.
            </summary>
            <returns>The list of bucket labels, after processing.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.Collator">
            <summary>
            Get a clone of the collator used internally. Note that for performance reasons, the clone is only done once, and
            then stored. The next time it is accessed, the same instance is returned.
            <para/>
            <b><i>Don't use this property across threads if you are changing the settings on the collator, at least not without
            synchronizing.</i></b>
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.AddRecord(System.String,`0)">
            <summary>
            Add a record (name and data) to the index. The name will be used to sort the items into buckets, and to sort
            within the bucket. Two records may have the same name. When they do, the sort order is according to the order added:
            the first added comes first.
            </summary>
            <param name="name">Name, such as a name.</param>
            <param name="data">Data, such as an address or link.</param>
            <returns>this, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.GetBucketIndex(System.String)">
            <summary>
            Get the bucket number for the given name. This routine permits callers to implement their own bucket handling
            mechanisms, including client-server handling. For example, when a new name is created on the client, it can ask
            the server for the bucket for that name, and the sortkey (using <see cref="P:ICU4N.Text.AlphabeticIndex`1.Collator"/>). Once the client has that
            information, it can put the name into the right bucket, and sort it within that bucket, without having access to
            the index or collator.
            <para/>
            Note that the bucket number (and sort key) are only valid for the settings of the current <see cref="T:ICU4N.Text.AlphabeticIndex`1"/>; if
            those are changed, then the bucket number and sort key must be regenerated.
            </summary>
            <param name="name">Name, such as a name.</param>
            <returns>The bucket index for the name.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.ClearRecords">
            <summary>
            Clear the index.
            </summary>
            <returns>This, for chaining.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.BucketCount">
            <summary>
            Gets the number of buckets in the index. This will be the same as the number of labels, plus buckets for the underflow, overflow, and inflow(s).
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.RecordCount">
            <summary>
            Gets the number of records in the index: that is, the total number of distinct &lt;name,data&gt; pairs added with AddRecord(...), over all the buckets.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.GetEnumerator">
            <summary>
            Return an enumerator over the buckets.
            </summary>
            <returns>Enumerator over buckets.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.InitBuckets">
            <summary>
            Creates an index, and buckets and sorts the list of records into the index.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.IsOneLabelBetterThanOther(ICU4N.Text.Normalizer2,System.String,System.String)">
            <summary>
            Returns true if one index character string is "better" than the other.
            Shorter NFKD is better, and otherwise NFKD-binary-less-than is
            better, and otherwise binary-less-than is better.
            </summary>
        </member>
        <member name="T:ICU4N.Text.AlphabeticIndex`1.Record">
            <summary>
            A (name, data) pair, to be sorted by name into one of the index buckets.
            The user data is not used by the index implementation.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.Record.Name">
            <summary>
            Gets the name.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.Record.Data">
            <summary>
            Gets the data.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.Record.ToString">
            <summary>
            Returns <c>name + "=" + data</c>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="T:ICU4N.Text.AlphabeticIndex`1.Bucket">
            <summary>
            An index "bucket" with a label string and type.
            It is referenced by <see cref="M:ICU4N.Text.AlphabeticIndex`1.GetBucketIndex(System.String)"/>
            and <see cref="M:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex.GetBucketIndex(System.String)"/>,
            returned by <see cref="M:ICU4N.Text.AlphabeticIndex`1.ImmutableIndex.GetBucket(System.Int32)"/>,
            and <see cref="M:ICU4N.Text.AlphabeticIndex`1.AddRecord(System.String,`0)"/> adds a record
            into a bucket according to the record's name.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.Bucket.#ctor(System.String,System.String,ICU4N.Text.BucketLabelType)">
            <summary>
            Set up the bucket.
            </summary>
            <param name="label">Label for the bucket.</param>
            <param name="lowerBoundary"></param>
            <param name="labelType">Is an underflow, overflow, or inflow bucket.</param>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.Bucket.Label">
            <summary>
            Gets the label for the bucket.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.Bucket.LabelType">
            <summary>
            Is a normal, underflow, overflow, or inflow bucket?
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.AlphabeticIndex`1.Bucket.Count">
            <summary>
            Gets the number of records in the bucket.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.Bucket.GetEnumerator">
            <summary>
            Enumerator over the records in the bucket.
            </summary>
            <returns>An enumerator over the records in the bucket.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.Bucket.ToString">
            <summary>
            Returns a name with the <see cref="F:ICU4N.Text.AlphabeticIndex`1.Bucket.labelType"/>, <see cref="F:ICU4N.Text.AlphabeticIndex`1.Bucket.lowerBoundary"/>, and <see cref="F:ICU4N.Text.AlphabeticIndex`1.Bucket.label"/>.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.BucketList.GetFullEnumerator">
            <summary>
            Private enumerator over all the buckets, visible and invisible
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.BucketList.GetEnumerator">
            <summary>
            Enumerator over just the visible buckets.
            </summary>
        </member>
        <member name="M:ICU4N.Text.AlphabeticIndex`1.GetFirstCharactersInScripts">
            <summary>
            Return a list of the first character in each script. Only exposed for testing.
            </summary>
            <returns>List of first characters in each script.</returns>
            <internal/>
        </member>
        <member name="T:ICU4N.Text.BucketLabelType">
            <summary>
            Type of the label
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.BucketLabelType.Normal">
            <summary>
            Normal
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.BucketLabelType.Underflow">
            <summary>
            Underflow (before the first)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.BucketLabelType.Inflow">
            <summary>
            Inflow (between scripts)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.BucketLabelType.Overflow">
            <summary>
            Overflow (after the last)
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationElementIterator.dir_">
            &lt;0: backwards; 0: just after reset() (previous() begins from end);
            1: just after setOffset(); >1: forward
        </member>
        <member name="F:ICU4N.Text.CollationElementIterator.offsets_">
            Stores offsets from expansions and from unsafe-backwards iteration,
            so that getOffset() returns intermediate offsets for the CEs
            that are consistent with forward iteration.
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Text.CollationElementIterator.NULLORDER" -->
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Text.CollationElementIterator.IGNORABLE" -->
        <member name="M:ICU4N.Text.CollationElementIterator.PrimaryOrder(System.Int32)">
            Return the primary order of the specified collation element,
            i.e. the first 16 bits.  This value is unsigned.
            @param ce the collation element
            @return the element's 16 bits primary order.
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.SecondaryOrder(System.Int32)">
            Return the secondary order of the specified collation element,
            i.e. the 16th to 23th bits, inclusive.  This value is unsigned.
            @param ce the collation element
            @return the element's 8 bits secondary order
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.TertiaryOrder(System.Int32)">
            Return the tertiary order of the specified collation element, i.e. the last
            8 bits.  This value is unsigned.
            @param ce the collation element
            @return the element's 8 bits tertiary order
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.#ctor(System.String,ICU4N.Text.RuleBasedCollator)">
             CollationElementIterator constructor. This takes a source
             string and a RuleBasedCollator. The iterator will walk through
             the source string based on the rules defined by the
             collator. If the source string is empty, NULLORDER will be
             returned on the first call to next().
            
             @param source the source string.
             @param collator the RuleBasedCollator
             @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.#ctor(ICU4N.Support.Text.CharacterIterator,ICU4N.Text.RuleBasedCollator)">
             CollationElementIterator constructor. This takes a source
             character iterator and a RuleBasedCollator. The iterator will
             walk through the source string based on the rules defined by
             the collator. If the source string is empty, NULLORDER will be
             returned on the first call to next().
            
             @param source the source string iterator.
             @param collator the RuleBasedCollator
             @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.#ctor(ICU4N.Text.UCharacterIterator,ICU4N.Text.RuleBasedCollator)">
             CollationElementIterator constructor. This takes a source
             character iterator and a RuleBasedCollator. The iterator will
             walk through the source string based on the rules defined by
             the collator. If the source string is empty, NULLORDER will be
             returned on the first call to next().
            
             @param source the source string iterator.
             @param collator the RuleBasedCollator
             @stable ICU 2.8
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.CollationElementIterator.GetOffset" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.CollationElementIterator.Next" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.CollationElementIterator.Previous" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.CollationElementIterator.Reset" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.CollationElementIterator.SetOffset(System.Int32)" -->
        <member name="M:ICU4N.Text.CollationElementIterator.SetText(System.String)">
             Set a new source string for iteration, and reset the offset
             to the beginning of the text.
            
             @param source the new source string for iteration.
             @stable ICU 2.8
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.CollationElementIterator.SetText(ICU4N.Text.UCharacterIterator)" -->
        <member name="M:ICU4N.Text.CollationElementIterator.SetText(ICU4N.Support.Text.CharacterIterator)">
             Set a new source string iterator for iteration, and reset the
             offset to the beginning of the text.
            
             @param source the new source string iterator for iteration.
             @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.GetMaxExpansion(System.Int32)">
             Returns the maximum length of any expansion sequence that ends with
             the specified collation element. If there is no expansion with this
             collation element as the last element, returns 1.
            
             @param ce a collation element returned by previous() or next().
             @return the maximum length of any expansion sequence ending
                     with the specified collation element.
             @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.NormalizeDir">
            Normalizes dir_=1 (just after setOffset()) to dir_=0 (just after reset()). 
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.Equals(System.Object)">
            Tests that argument object is equals to this CollationElementIterator.
            Iterators are equal if the objects uses the same RuleBasedCollator,
            the same source text and have the same current position in iteration.
            @param that object to test if it is equals to this
                        CollationElementIterator
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.CollationElementIterator.GetHashCode">
            Mock implementation of hashCode(). This implementation always returns a constant
            value. When Java assertion is enabled, this method triggers an assertion failure.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="P:ICU4N.Text.CollationElementIterator.RuleBasedCollator">
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="T:ICU4N.Text.CollationKeyBoundMode">
            <summary>
            Options that used in the API <see cref="M:ICU4N.Text.CollationKey.GetBound(ICU4N.Text.CollationKeyBoundMode,ICU4N.Text.CollationStrength)"/> for getting a
            <see cref="T:ICU4N.Text.CollationKey"/> based on the bound mode requested.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.CollationKeyBoundMode.Lower">
            <summary>
            Lower bound
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.CollationKeyBoundMode.Upper">
            <summary>
            Upper bound that will match strings of exact size.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.CollationKeyBoundMode.UpperLong">
            <summary>
            Upper bound that will match all the strings that have the same
            initial substring as the given string.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Text.CollationKey">
            <summary>
            A <see cref="T:ICU4N.Text.CollationKey"/> represents a <see cref="T:System.String"/>
            under the rules of a specific <see cref="T:ICU4N.Text.Collator"/> object.
            Comparing two <see cref="T:ICU4N.Text.CollationKey"/>s returns the
            relative order of the <see cref="T:System.String"/>s they represent.
            </summary>
            <remarks>
            Since the rule set of <see cref="T:ICU4N.Text.Collator"/>s can differ, the
            sort orders of the same string under two different
            <see cref="T:ICU4N.Text.Collator"/>s might differ.  Hence comparing
            <see cref="T:ICU4N.Text.CollationKey"/>s generated from different
            <see cref="T:ICU4N.Text.Collator"/>s can give incorrect results.
            <para/>
            Both the method
            <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> and the method
            <see cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/> compare two strings
            and returns their relative order.  The performance characteristics
            of these two approaches can differ.
            Note that collation keys are often less efficient than simply doing comparison.
            For more details, see the ICU User Guide.
            <para/>
            During the construction of a <see cref="T:ICU4N.Text.CollationKey"/>, the
            entire source string is examined and processed into a series of
            bits terminated by a null, that are stored in the <see cref="T:ICU4N.Text.CollationKey"/>.
            When <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> executes, it
            performs bitwise comparison on the bit sequences.  This can incur
            startup cost when creating the <see cref="T:ICU4N.Text.CollationKey"/>, but once
            the key is created, binary comparisons are fast.  This approach is
            recommended when the same strings are to be compared over and over
            again.
            <para/>
            On the other hand, implementations of
            <see cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/> can examine and
            process the strings only until the first characters differing in
            order.  This approach is recommended if the strings are to be
            compared only once.
            <para/>
            More information about the composition of the bit sequence can
            be found in the
            <a href="http://www.icu-project.org/userguide/Collate_ServiceArchitecture.html">
            user guide</a>.
            <para/>
            The following example shows how <see cref="T:ICU4N.Text.CollationKey"/>s can be used
            to sort a list of <see cref="T:System.String"/>s.
            
            <code>
            // Create an array of CollationKeys for the Strings to be sorted.
            Collator myCollator = Collator.GetInstance();
            CollationKey[] keys = new CollationKey[3];
            keys[0] = myCollator.GetCollationKey("Tom");
            keys[1] = myCollator.GetCollationKey("Dick");
            keys[2] = myCollator.GetCollationKey("Harry");
            Sort( keys );
            
            //...
            
            // Inside body of sort routine, compare keys this way
            if( keys[i].CompareTo( keys[j] ) &gt; 0 )
                // swap keys[i] and keys[j]
                
            //...
            
            // Finally, when we've returned from sort.
            Console.WriteLine(keys[0].SourceString);
            Console.WriteLine(keys[1].SourceString);
            Console.WriteLine(keys[2].SourceString);
            </code>
            <para/>
            This class is not subclassable
            </remarks>
            <seealso cref="T:ICU4N.Text.Collator"/>
            <seealso cref="T:ICU4N.Text.RuleBasedCollator"/>
            <author>Syn Wee Quek</author>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.#ctor(System.String,System.Byte[])">
            <summary>
            <see cref="T:ICU4N.Text.CollationKey"/> constructor.
            This constructor is given public access, unlike the <c>System.Globalization.SortKey</c>, to
            allow access to users extending the <see cref="T:ICU4N.Text.Collator"/> class. See
            <see cref="M:ICU4N.Text.Collator.GetCollationKey(System.String)"/>.
            </summary>
            <param name="source">String this <see cref="T:ICU4N.Text.CollationKey"/> is to represent.</param>
            <param name="key">Array of bytes that represent the collation order of argument
            source terminated by a null.</param>
            <seealso cref="T:ICU4N.Text.Collator"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.#ctor(System.String,System.Byte[],System.Int32)">
            <summary>
            Private constructor, takes a <paramref name="length"/> argument so it need not be lazy-evaluated.
            There must be a 00 byte at <paramref name="key"/>[<paramref name="length"/>] and none before.
            </summary>
        </member>
        <member name="M:ICU4N.Text.CollationKey.#ctor(System.String,ICU4N.Text.RawCollationKey)">
            <summary>
            <see cref="T:ICU4N.Text.CollationKey"/> constructor that forces key to release its internal byte
            array for adoption. key will have a null byte array after this
            construction.
            </summary>
            <param name="source">String this <see cref="T:ICU4N.Text.CollationKey"/> is to represent.</param>
            <param name="key"><see cref="T:ICU4N.Text.RawCollationKey"/> object that represents the collation order of
            argument source.</param>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.CollationKey.SourceString">
            <summary>
            Gets the source string that this <see cref="T:ICU4N.Text.CollationKey"/> represents.
            </summary>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.ToByteArray">
            <summary>
            Duplicates and returns the value of this <see cref="T:ICU4N.Text.CollationKey"/> as a sequence
            of big-endian bytes terminated by a null.
            </summary>
            <remarks>
            If two <see cref="T:ICU4N.Text.CollationKey"/>s can be legitimately compared, then one can
            compare the byte arrays of each to obtain the same result, e.g.
            <code>
            byte key1[] = collationkey1.ToByteArray();
            byte key2[] = collationkey2.ToByteArray();
            int key, targetkey;
            int i = 0;
            do
            {
                key = key1[i] &amp; 0xFF;
                targetkey = key2[i] &amp; 0xFF;
                if (key &lt; targetkey)
                {
                    Console.WriteLine("String 1 is less than string 2");
                    return;
                }
                if (targetkey &lt; key)
                {
                    Console.WriteLine("String 1 is more than string 2");
                }
                i++;
            } while (key != 0 &amp;&amp; targetKey != 0);
            
            Console.WriteLine("Strings are equal.");
            </code>
            </remarks>
            <returns>
            <see cref="T:ICU4N.Text.CollationKey"/> value in a sequence of big-endian byte bytes
            terminated by a null.
            </returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.CollationKey"/> to another <see cref="T:ICU4N.Text.CollationKey"/>.  The
            collation rules of the <see cref="T:ICU4N.Text.Collator"/> that created this key are
            applied.
            </summary>
            <remarks>
            <strong>Note:</strong> Comparison between <see cref="T:ICU4N.Text.CollationKey"/>s
            created by different <see cref="T:ICU4N.Text.Collator"/>s might return incorrect
            results.  See class documentation.
            </remarks>
            <param name="target">Target <see cref="T:ICU4N.Text.CollationKey"/>.</param>
            <returns>
            An integer value.  If the value is less than zero this CollationKey
            is less than than target, if the value is zero they are equal, and
            if the value is greater than zero this <see cref="T:ICU4N.Text.CollationKey"/> is greater
            than target.
            </returns>
            <exception cref="T:System.ArgumentNullException">is thrown if argument is null.</exception>
            <seealso cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.CompareTo(System.Object)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.CollationKey"/> to another <see cref="T:ICU4N.Text.CollationKey"/>.  The
            collation rules of the <see cref="T:ICU4N.Text.Collator"/> that created this key are
            applied.
            </summary>
            <remarks>
            <strong>Note:</strong> Comparison between <see cref="T:ICU4N.Text.CollationKey"/>s
            created by different <see cref="T:ICU4N.Text.Collator"/>s might return incorrect
            results.  See class documentation.
            </remarks>
            <param name="target">Target <see cref="T:ICU4N.Text.CollationKey"/>.</param>
            <returns>
            An integer value.  If the value is less than zero this CollationKey
            is less than than target, if the value is zero they are equal, and
            if the value is greater than zero this <see cref="T:ICU4N.Text.CollationKey"/> is greater
            than target.
            </returns>
            <exception cref="T:System.ArgumentNullException">is thrown if argument is null.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="other"/> cannot be cast to <see cref="T:ICU4N.Text.CollationKey"/>.</exception>
            <seealso cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/>
            <stable>ICU4N 60.1</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.Equals(System.Object)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.CollationKey"/> and the specified <see cref="T:System.Object"/> for
            equality.  The collation rules of the <see cref="T:ICU4N.Text.Collator"/> that created
            this key are applied.
            <para/>
            See note in <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> for warnings about
            possible incorrect results.
            </summary>
            <param name="target">The object to compare to.</param>
            <returns>true if the two keys compare as equal, false otherwise.</returns>
            <seealso cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/>
            <seealso cref="M:ICU4N.Text.CollationKey.CompareTo(System.Object)"/>
        </member>
        <member name="M:ICU4N.Text.CollationKey.Equals(ICU4N.Text.CollationKey)">
            <summary>
            Compare this <see cref="T:ICU4N.Text.CollationKey"/> and the argument target <see cref="T:ICU4N.Text.CollationKey"/> for
            equality.
            The collation
            rules of the <see cref="T:ICU4N.Text.Collator"/> object which created these objects are applied.
            <para/>
            See note in <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> for warnings of incorrect results
            </summary>
            <param name="target">The <see cref="T:ICU4N.Text.CollationKey"/> to compare to.</param>
            <returns>true if two objects are equal, false otherwise.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.GetHashCode">
            <summary>
            Returns a hash code for this CollationKey. The hash value is calculated
            on the key itself, not the string from which the key was created. Thus
            if x and y are <see cref="T:ICU4N.Text.CollationKey"/>s, then x.GetHashCode(x) == y.GetHashCode()
            if x.Equals(y) is true. This allows language-sensitive comparison in a
            <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>The hash value.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.GetBound(ICU4N.Text.CollationKeyBoundMode,ICU4N.Text.CollationStrength)">
            <summary>
            Produces a bound for the sort order of a given collation key and a
            strength level. This API does not attempt to find a bound for the
            <see cref="T:ICU4N.Text.CollationKey"/> string representation, hence null will be returned in its
            place.
            </summary>
            <remarks>
            Resulting bounds can be used to produce a range of strings that are
            between upper and lower bounds. For example, if bounds are produced
            for a sortkey of string "smith", strings between upper and lower
            bounds with primary strength would include "Smith", "SMITH", "sMiTh".
            <para/>
            There are two upper bounds that can be produced. If <see cref="F:ICU4N.Text.CollationKeyBoundMode.Upper"/>
            is produced, strings matched would be as above. However, if a bound
            is produced using <see cref="F:ICU4N.Text.CollationKeyBoundMode.UpperLong"/> is used, the above example will
            also match "Smithsonian" and similar.
            <para/>
            For more on usage, see example in test procedure
            <a href="http://source.icu-project.org/repos/icu/icu4j/trunk/src/com/ibm/icu/dev/test/collator/CollationAPITest.java">
            src/com/ibm/icu/dev/test/collator/CollationAPITest/TestBounds.
            </a>
            <para/>
            Collation keys produced may be compared using the <see cref="M:ICU4N.Text.CollationKey.CompareTo(ICU4N.Text.CollationKey)"/> API.
            </remarks>
            <param name="boundType">
            Mode of bound required. It can be <see cref="F:ICU4N.Text.CollationKeyBoundMode.Lower"/>, which
            produces a lower inclusive bound, <see cref="F:ICU4N.Text.CollationKeyBoundMode.Upper"/>, that
            produces upper bound that matches strings of the same
            length or <see cref="F:ICU4N.Text.CollationKeyBoundMode.UpperLong"/> that matches strings that
            have the same starting substring as the source string.
            </param>
            <param name="noOfLevels">
            Strength levels required in the resulting bound
            (for most uses, the recommended value is <see cref="F:ICU4N.Text.CollationStrength.Primary"/>). This
            strength should be less than the maximum strength of
            this <see cref="T:ICU4N.Text.CollationKey"/>.
            See users guide for explanation on the strength levels a
            collation key can have.
            </param>
            <returns>
            The result bounded <see cref="T:ICU4N.Text.CollationKey"/> with a valid sort order but
            a null string representation.
            </returns>
            <exception cref="T:System.ArgumentException">
            thrown when the strength level
            requested is higher than or equal to the strength in this
            <see cref="T:ICU4N.Text.CollationKey"/>.
            In the case of an Exception, information
            about the maximum strength to use will be returned in the
            Exception. The user can then call <see cref="M:ICU4N.Text.CollationKey.GetBound(ICU4N.Text.CollationKeyBoundMode,ICU4N.Text.CollationStrength)"/> again with the
            appropriate strength.
            </exception>
            <seealso cref="T:ICU4N.Text.CollationKey"/>
            <seealso cref="T:ICU4N.Text.CollationKeyBoundMode"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Primary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Secondary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Tertiary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Quaternary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Identical"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.CollationKey.Merge(ICU4N.Text.CollationKey)">
            <summary>
            Merges this <see cref="T:ICU4N.Text.CollationKey"/> with another.
            The levels are merged with their corresponding counterparts
            (primaries with primaries, secondaries with secondaries etc.).
            Between the values from the same level a separator is inserted.
            </summary>
            <remarks>
            This is useful, for example, for combining sort keys from first and last names
            to sort such pairs.
            See <a href="http://www.unicode.org/reports/tr10/#Merging_Sort_Keys">http://www.unicode.org/reports/tr10/#Merging_Sort_Keys</a>.
            <para/>
            The recommended way to achieve "merged" sorting is by
            concatenating strings with U+FFFE between them.
            The concatenation has the same sort order as the merged sort keys,
            but Merge(GetCollationKey(str1), GetCollationKey(str2)) may differ from GetCollationKey(str1 + '\uFFFE' + str2).
            Using strings with U+FFFE may yield shorter sort keys.
            <para/>
            For details about Sort Key Features see
            <a href="http://userguide.icu-project.org/collation/api#TOC-Sort-Key-Features">http://userguide.icu-project.org/collation/api#TOC-Sort-Key-Features</a>.
            <para/>
            It is possible to merge multiple sort keys by consecutively merging
            another one with the intermediate result.
            <para/>
            Only the sort key bytes of the <see cref="T:ICU4N.Text.CollationKey"/>s are merged.
            This API does not attempt to merge the
            string representations of the <see cref="T:ICU4N.Text.CollationKey"/>s, hence null will be returned
            as the result's string representation.
            <para/>
            Example (uncompressed):
            <code>
            191B1D 01 050505 01 910505 00
            1F2123 01 050505 01 910505 00
            </code>
            will be merged as
            <code>
            191B1D 02 1F2123 01 050505 02 050505 01 910505 02 910505 00
            </code>
            </remarks>
            <param name="source"><see cref="T:ICU4N.Text.CollationKey"/> to merge with.</param>
            <returns>A <see cref="T:ICU4N.Text.CollationKey"/> that contains the valid merged sort keys
            with a null String representation,
            i.e. <c>new CollationKey(null, merged_sort_keys)</c>.</returns>
            <exception cref="T:System.ArgumentException">Thrown if source <see cref="T:ICU4N.Text.CollationKey"/>
            argument is null or of 0 length.</exception>
            <stable>ICU 2.6</stable>
        </member>
        <member name="F:ICU4N.Text.CollationKey.m_key_">
            <summary>
            Sequence of bytes that represents the sort key
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationKey.m_source_">
            <summary>
            Source string this <see cref="T:ICU4N.Text.CollationKey"/> represents
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationKey.m_hashCode_">
            <summary>
            Hash code for the key
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationKey.m_length_">
            <summary>
            Gets the length of this <see cref="T:ICU4N.Text.CollationKey"/>
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationKey.MERGE_SEPERATOR_">
            <summary>
            Collation key merge seperator
            </summary>
        </member>
        <member name="M:ICU4N.Text.CollationKey.GetLength">
            <summary>
            Gets the length of the <see cref="T:ICU4N.Text.CollationKey"/>.
            </summary>
            <returns>Length of the <see cref="T:ICU4N.Text.CollationKey"/>.</returns>
        </member>
        <member name="T:ICU4N.Text.CollationStrength">
            <summary>Use this to set the strength of a Collator object.
             This is also used to determine the strength of sort keys
             generated from Collator objects
            The usual strength for most locales (except Japanese) is tertiary.
            Quaternary strength is useful when combined with shifted setting
            for alternate handling attribute and for JIS x 4061 collation,
            when it is used to distinguish between Katakana and Hiragana
            (this is achieved by setting the <see cref="P:ICU4N.Text.RuleBasedCollator.IsHiraganaQuaternary"/> to true.
            Otherwise, quaternary level is affected only by the number of
            non ignorable code points in the string.
            </summary>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Primary">
            <summary>
            Strongest collator strength value. Typically used to denote differences
            between base characters. See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Base letter represents a primary difference.  Set comparison
            level to Primary to ignore secondary and tertiary differences.
            Example of primary difference, "abc" &lt; "abd"
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Secondary">
            <summary>
            Second level collator strength value.
            Accents in the characters are considered secondary differences.
            Other differences between letters can also be considered secondary
            differences, depending on the language.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Diacritical differences on the same base letter represent a secondary
            difference.  Set comparison level to Secondary to ignore tertiary
            differences.
            Example of secondary difference, "a&#x308;" >> "a".
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Tertiary">
            <summary>
            Third level collator strength value.
            Upper and lower case differences in characters are distinguished at this
            strength level. In addition, a variant of a letter differs from the base
            form on the tertiary level.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Set comparison level to Tertiary to include
            all comparison differences.
            Example of tertiary difference, "abc" &lt;&lt;&lt; "ABC".
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Quaternary">
            <summary>
            <icu/>Fourth level collator strength value.
            When punctuation is ignored
            (see <a href="http://userguide.icu-project.org/collation/concepts#TOC-Ignoring-Punctuation">Ignoring Punctuation in the User Guide</a>) 
            at <see cref="F:ICU4N.Text.CollationStrength.Primary"/> to <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/>
            strength, an additional strength level can
            be used to distinguish words with and without punctuation.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Quaternary level is usually only affected by the number of
            non-ignorable code points in the string.
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.CollationStrength.Identical">
            <summary>
            Smallest <see cref="T:ICU4N.Text.Collator"/> strength value. When all other strengths are equal,
            the IDENTICAL strength is used as a tiebreaker. The Unicode code point
            values of the NFD form of each string are compared, just in case there
            is no difference.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Note this value is different from JDK's
            <para/>
            Two characters are considered "identical" when they have the same
            unicode spellings.
            For example, "a&#x308;" == "a&#x308;".
            </summary>
            <remarks>Identical strength is rarely useful, as it amounts to
            codepoints of the NFD form of the string</remarks>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.NormalizationMode.NoDecomposition">
            <summary>
            Decomposition mode value. With <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/> set, Strings
            will not be decomposed for collation. This is the default
            decomposition setting unless otherwise specified by the locale
            used to create the <see cref="T:ICU4N.Text.Collator"/>.
            <para/>
            <strong>Note</strong> this value is different from the JDK's.
            </summary>
            <seealso cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/>
            <seealso cref="P:ICU4N.Text.Collator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition">
            <summary>
            Decomposition mode value. With <see cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/> set,
            characters that are canonical variants according to the Unicode standard
            will be decomposed for collation.
            <para/>
            <see cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/> corresponds to Normalization Form D as
            described in <a href="http://www.unicode.org/unicode/reports/tr15/">Unicode Technical Report #15</a>.
            </summary>
            <seealso cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/>
            <seealso cref="P:ICU4N.Text.Collator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="T:ICU4N.Text.ReorderCodes">
            <summary>
             Reordering codes for non-script groups that can be reordered under collation.
            </summary>
            <see cref="M:ICU4N.Text.Collator.GetReorderCodes"/>
            <see cref="M:ICU4N.Text.Collator.SetReorderCodes(System.Int32[])"/>
            <see cref="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Default">
            <summary>
            A special reordering code that is used to specify the default reordering codes for a locale.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.None">
            <summary>
            A special reordering code that is used to specify no reordering codes.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Others">
            <summary>
            A special reordering code that is used to specify all other codes used for reordering except
            for the codes listed as ReorderingCodes and those listed explicitly in a reordering.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Space">
            <summary>
            Characters with the space property.
            This is equivalent to the rule value "space".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.First">
            <summary>
            The first entry in the enumeration of reordering groups. This is intended for use in
            range checking and enumeration of the reorder codes.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Punctuation">
            <summary>
            Characters with the punctuation property.
            This is equivalent to the rule value "punct".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Symbol">
            <summary>
            Characters with the symbol property.
            This is equivalent to the rule value "symbol".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Currency">
            <summary>
            Characters with the currency property.
            This is equivalent to the rule value "currency".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Digit">
            <summary>
            Characters with the digit property.
            This is equivalent to the rule value "digit".
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="F:ICU4N.Text.ReorderCodes.Limit">
            <summary>
            One more than the highest normal <see cref="T:ICU4N.Text.ReorderCodes"/> value.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:ICU4N.Text.Collator" -->
        <member name="F:ICU4N.Text.Collator.Primary">
            <summary>
            Strongest collator strength value. Typically used to denote differences
            between base characters. See class documentation for more explanation.
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Secondary">
            <summary>
            Second level collator strength value.
            Accents in the characters are considered secondary differences.
            Other differences between letters can also be considered secondary
            differences, depending on the language.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Diacritical differences on the same base letter represent a secondary
            difference.  Set comparison level to Secondary to ignore tertiary
            differences.
            Example of secondary difference, "a&#x308;" >> "a".
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Tertiary">
            <summary>
            Third level collator strength value.
            Upper and lower case differences in characters are distinguished at this
            strength level. In addition, a variant of a letter differs from the base
            form on the tertiary level.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Set comparison level to Tertiary to include
            all comparison differences.
            Example of tertiary difference, "abc" &lt;&lt;&lt; "ABC".
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Quaternary">
            <summary>
            <icu/>Fourth level collator strength value.
            When punctuation is ignored
            (see <a href="http://userguide.icu-project.org/collation/concepts#TOC-Ignoring-Punctuation">Ignoring Punctuation in the User Guide</a>) 
            at <see cref="F:ICU4N.Text.Collator.Primary"/> to <see cref="F:ICU4N.Text.Collator.Tertiary"/>
            strength, an additional strength level can
            be used to distinguish words with and without punctuation.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Quaternary level is usually only affected by the number of
            non-ignorable code points in the string.
            </summary>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.Identical">
            <summary>
            Smallest <see cref="T:ICU4N.Text.Collator"/> strength value. When all other strengths are equal,
            the IDENTICAL strength is used as a tiebreaker. The Unicode code point
            values of the NFD form of each string are compared, just in case there
            is no difference.
            See <see cref="T:ICU4N.Text.Collator"/> documentation for more explanation.
            <para/>
            Note this value is different from JDK's
            <para/>
            Two characters are considered "identical" when they have the same
            unicode spellings.
            For example, "a&#x308;" == "a&#x308;".
            </summary>
            <remarks>Identical strength is rarely useful, as it amounts to
            codepoints of the NFD form of the string</remarks>
            <seealso cref="P:ICU4N.Text.Collator.Strength"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.NoDecomposition">
            <summary>
            Decomposition mode value. With <see cref="F:ICU4N.Text.Collator.NoDecomposition"/> set, Strings
            will not be decomposed for collation. This is the default
            decomposition setting unless otherwise specified by the locale
            used to create the <see cref="T:ICU4N.Text.Collator"/>.
            <para/>
            <strong>Note</strong> this value is different from the JDK's.
            </summary>
            <seealso cref="F:ICU4N.Text.Collator.CanonicalDecomposition"/>
            <see cref="P:ICU4N.Text.Collator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.CanonicalDecomposition">
            <summary>
            Decomposition mode value. With CANONICAL_DECOMPOSITION set,
            characters that are canonical variants according to the Unicode standard
            will be decomposed for collation.
            <para/>
            CANONICAL_DECOMPOSITION corresponds to Normalization Form D as
            described in <a href="http://www.unicode.org/unicode/reports/tr15/">Unicode Technical Report #15</a>.
            </summary>
            <see cref="F:ICU4N.Text.Collator.NoDecomposition"/>
            <see cref="P:ICU4N.Text.Collator.Decomposition"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Equals(System.Object)">
            <summary>
            Compares the equality of two <see cref="T:ICU4N.Text.Collator"/> objects. <see cref="T:ICU4N.Text.Collator"/> objects are equal if they have the same
            collation (sorting &amp; searching) behavior.
            <para/>
            The base class checks for null and for equal types.
            Subclasses should override.
            </summary>
            <param name="obj">the <see cref="T:ICU4N.Text.Collator"/> to compare to.</param>
            <returns>true if this <see cref="T:ICU4N.Text.Collator"/> has exactly the same collation behavior as obj, false otherwise.</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetHashCode">
            <summary>
            Generates a hash code for this <see cref="T:ICU4N.Text.Collator"/> object.
            <para/>
            The implementation exists just for consistency with <see cref="M:ICU4N.Text.Collator.Equals(System.Object)"/>
            implementation in this class and does not generate a useful hash code.
            Subclasses should override this implementation.
            </summary>
            <returns>a hash code value.</returns>
            <stable>ICU 58</stable>
        </member>
        <member name="P:ICU4N.Text.Collator.Strength">
            <summary>
            Gets or sets this <see cref="T:ICU4N.Text.Collator"/>'s strength attribute. The strength attribute
            determines the minimum level of difference considered significant
            during comparison.
            <para/>
            The base class setter does nothing. The base class getter always 
            returns <see cref="F:ICU4N.Text.CollationStrength.Tertiary"/>. Subclasses should override it if appropriate.
            <para/>
            See the <see cref="T:ICU4N.Text.Collator"/> class description for an example of use.
            </summary>
            <seealso cref="F:ICU4N.Text.CollationStrength.Primary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Secondary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Tertiary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Quaternary"/>
            <seealso cref="F:ICU4N.Text.CollationStrength.Identical"/>
            <exception cref="T:System.ArgumentException">if the new strength value is not valid.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.SetStrength2(ICU4N.Text.CollationStrength)">
            <summary>
            Internal, used in UnicodeTools.
            </summary>
            <param name="newStrength"></param>
            <returns>this, for chaining</returns>
        </member>
        <member name="P:ICU4N.Text.Collator.Decomposition">
            <summary>
            Gets or sets the decomposition mode of this <see cref="T:ICU4N.Text.Collator"/>.  Setting this
            decomposition attribute with <see cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/> allows the
            <see cref="T:ICU4N.Text.Collator"/> to handle un-normalized text properly, producing the
            same results as if the text were normalized. If
            <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/> is set, it is the user's responsibility to
            insure that all text is already in the appropriate form before
            a comparison or before getting a <see cref="T:ICU4N.Text.CollationKey"/>. Adjusting
            decomposition mode allows the user to select between faster and
            more complete collation behavior. The decomposition mode
            determines how Unicode composed characters are handled.
            See the <see cref="T:ICU4N.Text.Collator"/> description for more details.
            <para/>
            Since a great many of the world's languages do not require
            text normalization, most locales set <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/> as the
            default decomposition mode.
            <para/>
            The base class setter does nothing. The base class method always returns <see cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/>
            Subclasses should override it if appropriate.
            </summary>
            <seealso cref="F:ICU4N.Text.NormalizationMode.NoDecomposition"/>
            <seealso cref="F:ICU4N.Text.NormalizationMode.CanonicalDecomposition"/>
            <exception cref="T:System.ArgumentException">If the given value is not a valid decomposition mode.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.SetReorderCodes(System.Int32[])">
            <summary>
            Sets the reordering codes for this collator.
            Collation reordering allows scripts and some other groups of characters
            to be moved relative to each other. This reordering is done on top of
            the DUCET/CLDR standard collation order. Reordering can specify groups to be placed
            at the start and/or the end of the collation order. These groups are specified using
            <see cref="T:ICU4N.Globalization.UScript"/> codes and <see cref="T:ICU4N.Text.ReorderCodes"/> entries.
            <para/>
            By default, reordering codes specified for the start of the order are placed in the
            order given after several special non-script blocks. These special groups of characters
            are space, punctuation, symbol, currency, and digit. These special groups are represented with
            <see cref="T:ICU4N.Text.ReorderCodes"/> entries. Script groups can be intermingled with
            these special non-script groups if those special groups are explicitly specified in the reordering.
            <para/>
            The special code <see cref="F:ICU4N.Text.ReorderCodes.Others"/>
            stands for any script that is not explicitly
            mentioned in the list of reordering codes given. Anything that is after <see cref="F:ICU4N.Text.ReorderCodes.Others"/>
            will go at the very end of the reordering in the order given.
            <para/>
            The special reorder code <see cref="F:ICU4N.Text.ReorderCodes.Default"/>
            will reset the reordering for this collator
            to the default for this collator. The default reordering may be the DUCET/CLDR order or may be a reordering that
            was specified when this collator was created from resource data or from rules. The
            DEFAULT code <b>must</b> be the sole code supplied when it is used.
            If not, then an <see cref="T:System.ArgumentException"/> will be thrown.
            <para/>
            The special reorder code <see cref="F:ICU4N.Text.ReorderCodes.None"/>
            will remove any reordering for this collator.
            The result of setting no reordering will be to have the DUCET/CLDR ordering used. The
            <see cref="F:ICU4N.Text.ReorderCodes.None"/> code <b>must</b> be the sole code supplied when it is used.
            </summary>
            <param name="order">
            The reordering codes to apply to this collator; if this is null or an empty array
            then this clears any existing reordering.
            </param>
            <seealso cref="M:ICU4N.Text.Collator.GetReorderCodes"/>
            <seealso cref="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)"/>
            <seealso cref="T:ICU4N.Text.ReorderCodes"/>
            <seealso cref="T:ICU4N.Globalization.UScript"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetInstance">
            <summary>
            Returns the <see cref="T:ICU4N.Text.Collator"/> for the current default locale.
            The default locale is determined by <see cref="P:System.Globalization.CultureInfo.CurrentCulture"/>.
            </summary>
            <returns>
            The <see cref="T:ICU4N.Text.Collator"/> for the default locale (for example, en-US) if it
            is created successfully. Otherwise if there is no <see cref="T:ICU4N.Text.Collator"/>
            associated with the current locale, the root collator
            will be returned.
            </returns>
            <seealso cref="P:System.Globalization.CultureInfo.CurrentCulture"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Clone">
            <summary>
            Clones the collator.
            </summary>
            <returns>A clone of this collator.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Text.Collator.CollatorFactory">
            <summary>
            A factory used with <see cref="M:ICU4N.Text.Collator.RegisterFactory(ICU4N.Text.Collator.CollatorFactory)"/> to register multiple collators and provide
            display names for them.  If standard locale display names are sufficient,
            Collator instances may be registered instead.
            <para/>
            <b>Note:</b> as of ICU4N 3.2, the default API for <see cref="T:ICU4N.Text.Collator.CollatorFactory"/> uses
            <see cref="T:ICU4N.Util.ULocale"/> instead of <see cref="T:System.Globalization.CultureInfo"/>.  Instead of overriding <see cref="M:ICU4N.Text.Collator.CollatorFactory.CreateCollator(System.Globalization.CultureInfo)"/>,
            new implementations should override <see cref="M:ICU4N.Text.Collator.CollatorFactory.CreateCollator(ICU4N.Util.ULocale)"/>.  Note that
            one of these two methods <b>MUST</b> be overridden or else an infinite
            loop will occur.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="P:ICU4N.Text.Collator.CollatorFactory.Visible">
            <summary>
            Return true if this factory will be visible.  Default is true.
            If not visible, the locales supported by this factory will not
            be listed by <see cref="M:ICU4N.Text.Collator.GetAvailableLocales"/>.
            <para/>
            true if this factory is visible.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.CollatorFactory.CreateCollator(ICU4N.Util.ULocale)">
            <summary>
            Return an instance of the appropriate collator.  If the locale
            is not supported, return null.
            <para/>
            <b>Note:</b> as of ICU4N 3.2, implementations should override
            this method instead of <see cref="M:ICU4N.Text.Collator.CollatorFactory.CreateCollator(System.Globalization.CultureInfo)"/>.
            </summary>
            <param name="loc">the locale for which this collator is to be created.</param>
            <returns>the newly created collator.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.CollatorFactory.CreateCollator(System.Globalization.CultureInfo)">
            <summary>
            Return an instance of the appropriate collator.  If the locale
            is not supported, return null.
            <para/>
            <b>Note:</b> as of ICU4J 3.2, implementations should override
            createCollator(ULocale) instead of this method, and inherit this
            method's implementation.  This method is no longer abstract
            and instead delegates to createCollator(ULocale).
            </summary>
            <param name="loc">the locale for which this collator is to be created.</param>
            <returns>the newly created collator.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.CollatorFactory.GetDisplayName(System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
            <summary>
            Return the name of the collator for the <paramref name="objectLocale"/>, localized for the <paramref name="displayLocale"/>.
            If <paramref name="objectLocale"/> is not visible or not defined by the factory, return null.
            </summary>
            <param name="objectLocale">the locale identifying the collator</param>
            <param name="displayLocale">the locale for which the display name of the collator should be localized</param>
            <returns>the display name</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.CollatorFactory.GetDisplayName(ICU4N.Util.ULocale,ICU4N.Util.ULocale)">
            <summary>
            Return the name of the collator for the <paramref name="objectLocale"/>, localized for the <paramref name="displayLocale"/>.
            If <paramref name="objectLocale"/> is not visible or not defined by the factory, return null.
            </summary>
            <param name="objectLocale">the locale identifying the collator</param>
            <param name="displayLocale">the locale for which the display name of the collator should be localized</param>
            <returns>the display name</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.CollatorFactory.GetSupportedLocaleIDs">
            <summary>
            Return an unmodifiable collection of the locale names directly
            supported by this factory.
            </summary>
            <returns>the set of supported locale IDs.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.CollatorFactory.#ctor">
            <summary>
            Empty default constructor.
            </summary>
            <stable>ICU 2.6</stable>
        </member>
        <member name="T:ICU4N.Text.Collator.ASCII">
            <summary>
            Simpler/faster methods for ASCII than ones based on Unicode data.
            TODO: There should be code like this somewhere already??
            </summary>
        </member>
        <member name="M:ICU4N.Text.Collator.SetAttributesFromKeywords(ICU4N.Util.ULocale,ICU4N.Text.Collator,ICU4N.Text.RuleBasedCollator)">
            <summary>
            Sets collation attributes according to locale keywords. See
            http://www.unicode.org/reports/tr35/tr35-collation.html#Collation_Settings
            <para/>
            Using "alias" keywords and values where defined:
            http://www.unicode.org/reports/tr35/tr35.html#Old_Locale_Extension_Syntax
            http://unicode.org/repos/cldr/trunk/common/bcp47/collation.xml
            </summary>
            <param name="loc"></param>
            <param name="coll"></param>
            <param name="rbc"></param>
        </member>
        <member name="M:ICU4N.Text.Collator.GetInstance(ICU4N.Util.ULocale)">
            <summary>
            <icu/> Returns the <see cref="T:ICU4N.Text.Collator"/> for the desired locale.
            <para/>
            For some languages, multiple collation types are available;
            for example, "de@collation=phonebook".
            Starting with ICU 54, collation attributes can be specified via locale keywords as well,
            in the old locale extension syntax ("el@colCaseFirst=upper")
            or in language tag syntax ("el-u-kf-upper").
            See <a href="http://userguide.icu-project.org/collation/api">User Guide: Collation API</a>.
            </summary>
            <param name="locale">the desired locale.</param>
            <returns>
            <see cref="T:ICU4N.Text.Collator"/> for the desired locale if it is created successfully.
            Otherwise if there is no Collator
            associated with the current locale, the root collator will
            be returned.
            </returns>
            <seealso cref="T:System.Globalization.CultureInfo"/>
            <seealso cref="T:ICU4N.Util.ResourceBundle"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)">
            <summary>
            Returns the <see cref="T:ICU4N.Text.Collator"/> for the desired locale.
            <para/>
            For some languages, multiple collation types are available;
            for example, "de-u-co-phonebk".
            Starting with ICU 54, collation attributes can be specified via locale keywords as well,
            in the old locale extension syntax ("el@colCaseFirst=upper", only with <see cref="T:ICU4N.Util.ULocale"/>)
            or in language tag syntax ("el-u-kf-upper").
            See <a href="http://userguide.icu-project.org/collation/api">User Guide: Collation API</a>.
            </summary>
            <param name="locale">the desired locale.</param>
            <returns>
            <see cref="T:ICU4N.Text.Collator"/> for the desired locale if it is created successfully.
            Otherwise if there is no <see cref="T:ICU4N.Text.Collator"/>
            associated with the current locale, the root collator will
            be returned.
            </returns>
            <seealso cref="T:System.Globalization.CultureInfo"/>
            <seealso cref="T:ICU4N.Util.ResourceBundle"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance(System.Globalization.CultureInfo)"/>
            <seealso cref="M:ICU4N.Text.Collator.GetInstance"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.RegisterInstance(ICU4N.Text.Collator,ICU4N.Util.ULocale)">
            <summary>
            <icu/> Registers a collator as the default collator for the provided locale.  The
            collator should not be modified after it is registered.
            <para/>
            Because ICU may choose to cache Collator objects internally, this must
            be called at application startup, prior to any calls to
            <see cref="M:ICU4N.Text.Collator.GetInstance"/> to avoid undefined behavior.
            </summary>
            <param name="collator">the collator to register</param>
            <param name="locale">the locale for which this is the default collator</param>
            <returns>an object that can be used to unregister the registered collator.</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.RegisterFactory(ICU4N.Text.Collator.CollatorFactory)">
            <summary>
            <icu/> Registers a collator factory.
            <para/>
            Because ICU may choose to cache Collator objects internally, this must
            be called at application startup, prior to any calls to
            <see cref="M:ICU4N.Text.Collator.GetInstance"/> to avoid undefined behavior.
            </summary>
            <param name="factory">the factory to register</param>
            <returns>an object that can be used to unregister the registered factory.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Unregister(System.Object)">
            <summary>
            <icu/> Unregisters a collator previously registered using <see cref="M:ICU4N.Text.Collator.RegisterInstance(ICU4N.Text.Collator,ICU4N.Util.ULocale)"/>.
            </summary>
            <param name="registryKey">the object previously returned by <see cref="M:ICU4N.Text.Collator.RegisterInstance(ICU4N.Text.Collator,ICU4N.Util.ULocale)"/>.</param>
            <returns>true if the collator was successfully unregistered.</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetAvailableLocales">
            <summary>
            Returns the set of locales, as <see cref="T:System.Globalization.CultureInfo"/> objects, for which collators
            are installed.  Note that <see cref="T:System.Globalization.CultureInfo"/> objects do not support RFC 3066.
            </summary>
            <returns>
            the list of locales in which collators are installed.
            This list includes any that have been registered, in addition to
            those that are installed with ICU4N.
            </returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetAvailableULocales">
            <summary>
            <icu/> Returns the set of locales, as <see cref="T:ICU4N.Util.ULocale"/> objects, for which collators
            are installed.  <see cref="T:ICU4N.Util.ULocale"/> objects support RFC 3066.
            </summary>
            <returns>
            the list of locales in which collators are installed.
            This list includes any that have been registered, in addition to
            those that are installed with ICU4N.
            </returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="F:ICU4N.Text.Collator.KEYWORDS">
            <summary>
            The list of keywords for this service.  This must be kept in sync with
            the resource data.
            </summary>
            <since>ICU 3.0</since>
        </member>
        <member name="F:ICU4N.Text.Collator.RESOURCE">
            <summary>
            The resource name for this service.  Note that this is not the same as
            the keyword for this service.
            </summary>
            <since>ICU 3.0</since>
        </member>
        <member name="F:ICU4N.Text.Collator.BASE">
            <summary>
            The resource bundle base name for this service.
            </summary>
            <since>ICU 3.0</since>
        </member>
        <member name="P:ICU4N.Text.Collator.Keywords">
            <summary>
            <icu/> Returns a list of all possible keywords that are relevant to
            collation. At this point, the only recognized keyword for this
            service is "collation".
            </summary>
            <seealso cref="M:ICU4N.Text.Collator.GetKeywordValues(System.String)"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetKeywordValues(System.String)">
            <summary>
            <icu/> Given a keyword, returns an array of all values for
            that keyword that are currently in use.
            </summary>
            <param name="keyword">one of the keywords returned by <see cref="P:ICU4N.Text.Collator.Keywords"/>.</param>
            <returns></returns>
            <seealso cref="P:ICU4N.Text.Collator.Keywords"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetKeywordValuesForLocale(System.String,ICU4N.Util.ULocale,System.Boolean)">
            <summary>
            <icu/> Given a key and a locale, returns an array of string values in a preferred
            order that would make a difference. These are all and only those values where
            the open (creation) of the service with the locale formed from the input locale
            plus input keyword and that value has different behavior than creation with the
            input locale alone.
            </summary>
            <param name="key">
            one of the keys supported by this service.  For now, only
            "collation" is supported.
            </param>
            <param name="locale">the locale</param>
            <param name="commonlyUsed">if set to true it will return only commonly used values
            with the given locale in preferred order.  Otherwise,
            it will return all the available values for the locale.
            </param>
            <returns>An array of string values for the given key and the locale.</returns>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetFunctionalEquivalent(System.String,ICU4N.Util.ULocale,System.Boolean[])">
            <summary>
            <icu/> Returns the functionally equivalent locale for the given
            requested locale, with respect to given keyword, for the
            collation service.  If two locales return the same result, then
            collators instantiated for these locales will behave
            equivalently.  The converse is not always true; two collators
            may in fact be equivalent, but return different results, due to
            internal details.  The return result has no other meaning than
            that stated above, and implies nothing as to the relationship
            between the two locales.  This is intended for use by
            applications who wish to cache collators, or otherwise reuse
            collators when possible.  The functional equivalent may change
            over time.  For more information, please see the <a
            href="http://userguide.icu-project.org/locale#TOC-Locales-and-Services">
            Locales and Services</a> section of the ICU User Guide.
            </summary>
            <param name="keyword">A particular keyword as enumerated by <see cref="P:ICU4N.Text.Collator.Keywords"/>.</param>
            <param name="locID">The requested locale</param>
            <param name="isAvailable">If non-null, <paramref name="isAvailable"/>[0] will receive and
            output boolean that indicates whether the requested locale was
            'available' to the collation service. If non-null, <paramref name="isAvailable"/>
            must have length &gt;= 1.</param>
            <returns>the locale</returns>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetFunctionalEquivalent(System.String,ICU4N.Util.ULocale)">
            <summary>
            <icu/> Returns the functionally equivalent locale for the given
            requested locale, with respect to given keyword, for the
            collation service.
            </summary>
            <param name="keyword">a particular keyword as enumerated by <see cref="P:ICU4N.Text.Collator.Keywords"/>.</param>
            <param name="locID">The requested locale</param>
            <returns>the locale</returns>
            <seealso cref="M:ICU4N.Text.Collator.GetFunctionalEquivalent(System.String,ICU4N.Util.ULocale,System.Boolean[])"/>
            <stable>ICU 3.0</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetDisplayName(System.Globalization.CultureInfo,System.Globalization.CultureInfo)">
            <summary>
            <icu/> Returns the name of the collator for the <paramref name="objectLocale"/>, localized for the
            <paramref name="displayLocale"/>.
            </summary>
            <param name="objectLocale">the locale of the collator</param>
            <param name="displayLocale">the locale for the collator's display name</param>
            <returns>the display name</returns>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetDisplayName(ICU4N.Util.ULocale,ICU4N.Util.ULocale)">
            <summary>
            <icu/> Returns the name of the collator for the <paramref name="objectLocale"/>, localized for the
            <paramref name="displayLocale"/>.
            </summary>
            <param name="objectLocale">the locale of the collator</param>
            <param name="displayLocale">the locale for the collator's display name</param>
            <returns>the display name</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetDisplayName(System.Globalization.CultureInfo)">
            <summary>
            <icu/> Returns the name of the collator for the objectLocale, localized for the
            default <c>DISPLAY</c> locale.
            </summary>
            <param name="objectLocale">the locale of the collator</param>
            <returns>the display name</returns>
            <seealso cref="F:ICU4N.Util.ULocale.Category.DISPLAY"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetDisplayName(ICU4N.Util.ULocale)">
            <summary>
            <icu/> Returns the name of the collator for the objectLocale, localized for the
            default <c>DISPLAY</c> locale.
            </summary>
            <param name="objectLocale">the locale of the collator</param>
            <returns>the display name</returns>
            <stable>ICU 3.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Equals(System.String,System.String)">
            <summary>
            Compares the equality of two text Strings using
            this <see cref="T:ICU4N.Text.Collator"/>'s rules, strength and decomposition mode.  Convenience method.
            </summary>
            <param name="source">the source string to be compared.</param>
            <param name="target">the target string to be compared.</param>
            <returns>true if the strings are equal according to the collation rules, otherwise false.</returns>
            <exception cref="T:System.ArgumentNullException">thrown if either arguments is null.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetTailoredSet">
            <summary>
            <icu/> Returns a <see cref="T:ICU4N.Text.UnicodeSet"/> that contains all the characters and sequences tailored
            in this collator.
            </summary>
            <returns>
            A pointer to a UnicodeSet object containing all the
            code points and sequences that may sort differently than
            in the root collator.
            </returns>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Compare(System.String,System.String)">
            <summary>
            Compares the source text <see cref="T:System.String"/> to the target text <see cref="T:System.String"/> according to
            this <see cref="T:ICU4N.Text.Collator"/>'s rules, strength and decomposition mode.
            Returns an integer less than,
            equal to or greater than zero depending on whether the source String is
            less than, equal to or greater than the target <see cref="T:System.String"/>. See the <see cref="T:ICU4N.Text.Collator"/>
            class description for an example of use.
            </summary>
            <param name="source">the source string.</param>
            <param name="target">the target string.</param>
            <returns>
            Returns an integer value. Value is less than zero if source is
            less than target, value is zero if source and target are equal,
            value is greater than zero if source is greater than target.
            </returns>
            <exception cref="T:System.ArgumentNullException">thrown if either argument is null.</exception>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Compare(System.Object,System.Object)">
            <summary>
            Compares the source <see cref="T:System.Object"/> to the target <see cref="T:System.Object"/>.
            </summary>
            <param name="source">the source <see cref="T:System.Object"/>.</param>
            <param name="target">the target <see cref="T:System.Object"/>.</param>
            <returns>
            Returns an integer value. Value is less than zero if source is
            less than target, value is zero if source and target are equal,
            value is greater than zero if source is greater than target.
            </returns>
            <exception cref="T:System.InvalidCastException">thrown if either arguments cannot be cast to <see cref="T:System.String"/>.</exception>
            <stable>ICU 4.2</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.DoCompare(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence)">
            <summary>
            Compares two <see cref="T:ICU4N.Support.Text.ICharSequence"/>s.
            The base class just calls <c>Compare(left.ToString(), right.ToString())</c>.
            Subclasses should instead implement this method and have the String API call this method.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:ICU4N.Text.Collator.GetCollationKey(System.String)">
            <summary>
            Transforms the <see cref="T:System.String"/> into a <see cref="T:ICU4N.Text.CollationKey"/> suitable for efficient
            repeated comparison.  The resulting key depends on the collator's
            rules, strength and decomposition mode.
            <para/>
            Note that collation keys are often less efficient than simply doing comparison.
            For more details, see the ICU User Guide.
            <para/>
            See the CollationKey class documentation for more information.
            </summary>
            <param name="source">the <see cref="T:System.String"/> to be transformed into a <see cref="T:ICU4N.Text.CollationKey"/>.</param>
            <returns>
            The <see cref="T:ICU4N.Text.CollationKey"/> for the given <see cref="T:System.String"/> based on this <see cref="T:ICU4N.Text.Collator"/>'s
            collation rules. If the source <see cref="T:System.String"/> is null, a null
            <see cref="T:ICU4N.Text.CollationKey"/> is returned.
            </returns>
            <seealso cref="T:ICU4N.Text.CollationKey"/>
            <seealso cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/>
            <seealso cref="M:ICU4N.Text.Collator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)">
            <summary>
            <icu/> Returns the simpler form of a <see cref="T:ICU4N.Text.CollationKey"/> for the String source following
            the rules of this Collator and stores the result into the user provided argument
            key.  If key has a internal byte array of length that's too small for the result,
            the internal byte array will be grown to the exact required size.
            <para/>
            Note that collation keys are often less efficient than simply doing comparison.
            For more details, see the ICU User Guide.
            </summary>
            <param name="source">the text <see cref="T:System.String"/> to be transformed into a <see cref="T:ICU4N.Text.RawCollationKey"/></param>
            <param name="key"></param>
            <returns>
            If key is null, a new instance of <see cref="T:ICU4N.Text.RawCollationKey"/> will be
            created and returned, otherwise the user provided key will be
            returned.
            </returns>
            <seealso cref="M:ICU4N.Text.Collator.Compare(System.String,System.String)"/>
            <seealso cref="M:ICU4N.Text.Collator.GetCollationKey(System.String)"/>
            <seealso cref="T:ICU4N.Text.RawCollationKey"/>
            <stable>ICU 2.8</stable>
        </member>
        <member name="P:ICU4N.Text.Collator.MaxVariable">
            <summary>
            <icu/> Gets or sets the variable top to the top of the specified reordering group.
            The variable top determines the highest-sorting character
            which is affected by the alternate handling behavior.
            If that attribute is set to UCOL_NON_IGNORABLE, then the variable top has no effect.
            <para/>
            The base class setter throws a <see cref="T:System.NotSupportedException"/> and the getter
            returns <see cref="F:ICU4N.Text.ReorderCodes.Punctuation"/>.
            <para/>
            Valid values are one of <see cref="F:ICU4N.Text.ReorderCodes.Space"/>, <see cref="F:ICU4N.Text.ReorderCodes.Punctuation"/>,
            <see cref="F:ICU4N.Text.ReorderCodes.Symbol"/>, <see cref="F:ICU4N.Text.ReorderCodes.Currency"/>; 
            or <see cref="F:ICU4N.Text.ReorderCodes.Default"/> to restore the default max variable group.
            </summary>
            <stable>ICU 53</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.SetVariableTop(System.String)">
            <summary>
            <icu/> Sets the variable top to the primary weight of the specified string.
            <para/>
            Beginning with ICU 53, the variable top is pinned to
            the top of one of the supported reordering groups,
            and it must not be beyond the last of those groups.
            See the setter of <see cref="P:ICU4N.Text.Collator.MaxVariable"/>.
            </summary>
            <param name="varTop">
            one or more (if contraction) characters to which the
            variable top should be set
            </param>
            <returns>variable top primary weight</returns>
            <exception cref="T:System.ArgumentException">
            is thrown if varTop argument is not a valid variable top element. A variable top element is
            invalid when
            <list type="bullet">
                <item><description>it is a contraction that does not exist in the Collation order</description></item>
                <item><description>the variable top is beyond the last reordering group supported by <see cref="P:ICU4N.Text.Collator.MaxVariable"/></description></item>
                <item><description>when the <paramref name="varTop"/> argument is null or zero in length.</description></item>
            </list>
            </exception>
            <seealso cref="P:ICU4N.Text.RuleBasedCollator.IsAlternateHandlingShifted"/>
        </member>
        <member name="P:ICU4N.Text.Collator.VariableTop">
            <summary>
            Gets or sets the variable top to the specified primary weight.
            <para/>
            Beginning with ICU 53, the variable top is pinned to
            the top of one of the supported reordering groups,
            and it must not be beyond the last of those groups.
            See the setter for <see cref="P:ICU4N.Text.Collator.MaxVariable"/>.
            </summary>
            <seealso cref="M:ICU4N.Text.Collator.SetVariableTop(System.String)"/>
            <stable>ICU 2.6</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetVersion">
            <summary>
            <icu/> Returns the version of this collator object.
            </summary>
            <returns>the version object associated with this collator</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetUCAVersion">
            <summary>
            <icu/> Returns the UCA version of this collator object.
            </summary>
            <returns>the version object associated with this collator</returns>
            <stable>ICU 2.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetReorderCodes">
            <summary>
            Retrieves the reordering codes for this collator.
            These reordering codes are a combination of <see cref="T:ICU4N.Globalization.UScript"/> codes and <see cref="T:ICU4N.Text.ReorderCodes"/>.
            </summary>
            <returns>
            a copy of the reordering codes for this collator;
            if none are set then returns an empty array
            </returns>
            <seealso cref="M:ICU4N.Text.Collator.SetReorderCodes(System.Int32[])"/>
            <seealso cref="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)"/>
            <seealso cref="T:ICU4N.Text.ReorderCodes"/>
            <seealso cref="T:ICU4N.Globalization.UScript"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetEquivalentReorderCodes(System.Int32)">
            <summary>
            Retrieves all the reorder codes that are grouped with the given reorder code. Some reorder
            codes are grouped and must reorder together.
            Beginning with ICU 55, scripts only reorder together if they are primary-equal,
            for example Hiragana and Katakana.
            </summary>
            <param name="reorderCode">The reorder code to determine equivalence for.</param>
            <returns>The set of all reorder codes in the same group as the given reorder code.</returns>
            <seealso cref="M:ICU4N.Text.Collator.SetReorderCodes(System.Int32[])"/>
            <seealso cref="M:ICU4N.Text.Collator.GetReorderCodes"/>
            <seealso cref="T:ICU4N.Text.ReorderCodes"/>
            <seealso cref="T:ICU4N.Globalization.UScript"/>
            <stable>ICU 4.8</stable>
        </member>
        <member name="P:ICU4N.Text.Collator.IsFrozen">
            <summary>
            Determines whether the object has been frozen or not.
            <para/>
            An unfrozen <see cref="T:ICU4N.Text.Collator"/> is mutable and not thread-safe.
            A frozen <see cref="T:ICU4N.Text.Collator"/> is immutable and thread-safe.
            </summary>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.Freeze">
            <summary>
            Freezes the collator.
            </summary>
            <returns>The collator itself.</returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.CloneAsThawed">
            <summary>
            Provides for the clone operation. Any clone is initially unfrozen.
            </summary>
            <returns></returns>
            <stable>ICU 4.8</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.#ctor">
            <summary>
            Empty default constructor
            </summary>
            <stable>ICU 2.4</stable>
        </member>
        <member name="M:ICU4N.Text.Collator.GetLocale(ICU4N.Util.ULocale.Type)">
            <summary>
            <icu/> Returns the locale that was used to create this object, or null.
            This may may differ from the locale requested at the time of
            this object's creation.  For example, if an object is created
            for locale <c>en_US_CALIFORNIA</c>, the actual data may be
            drawn from <c>en</c> (the <i>actual</i> locale), and
            <c>en_US</c> may be the most specific locale that exists (the
            <i>valid</i> locale).
            <para/>
            Note: This method will be implemented in ICU 3.0; ICU 2.8
            contains a partial preview implementation.  The * <i>actual</i>
            locale is returned correctly, but the <i>valid</i> locale is
            not, in most cases.
            <para/>
            The base class method always returns <see cref="F:ICU4N.Util.ULocale.ROOT"/>
            Subclasses should override it if appropriate.
            </summary>
            <param name="type">type of information requested, either 
            <see cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/> or <see cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>.</param>
            <returns>
            the information specified by <i>type</i>, or null if
            this object was not constructed from locale data.
            </returns>
            <seealso cref="T:ICU4N.Util.ULocale"/>
            <seealso cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/>
            <seealso cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>
            <draft>ICU 2.8 (retain)</draft>
            <provisional>This API might change or be removed in a future release.</provisional>
        </member>
        <member name="M:ICU4N.Text.Collator.SetLocale(ICU4N.Util.ULocale,ICU4N.Util.ULocale)">
            <summary>
            Set information about the locales that were used to create this
            object.  If the object was not constructed from locale data,
            both arguments should be set to null.  Otherwise, neither
            should be null.  The actual locale must be at the same level or
            less specific than the valid locale.  This method is intended
            for use by factories or other entities that create objects of
            this class.
            <para/>
            The base class method does nothing. Subclasses should override it if appropriate.
            </summary>
            <param name="valid">the most specific locale containing any resource data, or null</param>
            <param name="actual">the locale containing data used to construct this object, or null</param>
            <seealso cref="T:ICU4N.Util.ULocale"/>
            <seealso cref="F:ICU4N.Util.ULocale.VALID_LOCALE"/>
            <seealso cref="F:ICU4N.Util.ULocale.ACTUAL_LOCALE"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.CollatorServiceShim.CService.ValidateFallbackLocale" -->
        <member name="M:ICU4N.Text.CollatorServiceShim.CService.HandleDefault(ICU4N.Impl.ICUService.Key,System.String[])">
            CLOVER:OFF
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.#ctor">
            Default constructor, internal byte array is null and its size set to 0.
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.#ctor(System.Int32)">
            RawCollationKey created with an empty internal byte array of length 
            capacity. Size of the internal byte array will be set to 0.
            @param capacity length of internal byte array
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.#ctor(System.Byte[])">
            RawCollationKey created, adopting bytes as the internal byte array.
            Size of the internal byte array will be set to 0.
            @param bytes byte array to be adopted by RawCollationKey
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.#ctor(System.Byte[],System.Int32)">
            Construct a RawCollationKey from a byte array and size.
            @param bytesToAdopt the byte array to adopt
            @param size the length of valid data in the byte array
            @throws IndexOutOfBoundsException if bytesToAdopt == null and size != 0, or
            size &lt; 0, or size &gt; bytesToAdopt.length.
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RawCollationKey.CompareTo(ICU4N.Util.ByteArrayWrapper)">
            Compare this RawCollationKey to another, which must not be null.  This overrides
            the inherited implementation to ensure the returned values are -1, 0, or 1.
            @param rhs the RawCollationKey to compare to.
            @return -1, 0, or 1 as this compares less than, equal to, or
            greater than rhs.
            @throws ClassCastException if the other object is not a RawCollationKey.
            @stable ICU 4.4
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.RuleBasedCollator.#ctor(System.String)" -->
        <member name="M:ICU4N.Text.RuleBasedCollator.InternalBuildTailoring(System.String)">
            Implements from-rule constructors.
            @param rules rule string
            @throws Exception
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.Clone">
            Clones the RuleBasedCollator
            
            @return a new instance of this RuleBasedCollator object
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetCollationElementIterator(System.String)">
            Return a CollationElementIterator for the given String.
            
            @see CollationElementIterator
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetCollationElementIterator(ICU4N.Support.Text.CharacterIterator)">
            Return a CollationElementIterator for the given CharacterIterator. The source iterator's integrity will be
            preserved since a new copy will be created for use.
            
            @see CollationElementIterator
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetCollationElementIterator(ICU4N.Text.UCharacterIterator)">
            Return a CollationElementIterator for the given UCharacterIterator. The source iterator's integrity will be
            preserved since a new copy will be created for use.
            
            @see CollationElementIterator
            @stable ICU 2.8
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Text.RuleBasedCollator.IsFrozen" -->
        <member name="M:ICU4N.Text.RuleBasedCollator.Freeze">
            Freezes the collator.
            @return the collator itself.
            @stable ICU 4.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.CloneAsThawed">
            Provides for the clone operation. Any clone is initially unfrozen.
            @stable ICU 4.8
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Text.RuleBasedCollator.IsHiraganaQuaternary" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.RuleBasedCollator.SetHiraganaQuaternaryDefault" -->
        <member name="P:ICU4N.Text.RuleBasedCollator.IsUpperCaseFirst">
            Sets whether uppercase characters sort before lowercase characters or vice versa, in strength TERTIARY. The
            default mode is false, and so lowercase characters sort before uppercase characters. If true, sort upper case
            characters first.
            
            @param upperfirst
                       true to sort uppercase characters before lowercase characters, false to sort lowercase characters
                       before uppercase characters
            @see #isLowerCaseFirst
            @see #isUpperCaseFirst
            @see #setLowerCaseFirst
            @see #setCaseFirstDefault
            @stable ICU 2.8
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsLowerCaseFirst">
            Sets the orders of lower cased characters to sort before upper cased characters, in strength TERTIARY. The
            default mode is false. If true is set, the RuleBasedCollator will sort lower cased characters before the upper
            cased ones. Otherwise, if false is set, the RuleBasedCollator will ignore case preferences.
            
            @param lowerfirst
                       true for sorting lower cased characters before upper cased characters, false to ignore case
                       preferences.
            @see #isLowerCaseFirst
            @see #isUpperCaseFirst
            @see #setUpperCaseFirst
            @see #setCaseFirstDefault
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetCaseFirstDefault">
            Sets the case first mode to the initial mode set during construction of the RuleBasedCollator. See
            setUpperCaseFirst(boolean) and setLowerCaseFirst(boolean) for more details.
            
            @see #isLowerCaseFirst
            @see #isUpperCaseFirst
            @see #setLowerCaseFirst(boolean)
            @see #setUpperCaseFirst(boolean)
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetAlternateHandlingDefault">
            Sets the alternate handling mode to the initial mode set during construction of the RuleBasedCollator. See
            setAlternateHandling(boolean) for more details.
            
            @see #setAlternateHandlingShifted(boolean)
            @see #isAlternateHandlingShifted()
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetCaseLevelDefault">
            Sets the case level mode to the initial mode set during construction of the RuleBasedCollator. See
            setCaseLevel(boolean) for more details.
            
            @see #setCaseLevel(boolean)
            @see #isCaseLevel
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetDecompositionDefault">
            Sets the decomposition mode to the initial mode set during construction of the RuleBasedCollator. See
            setDecomposition(int) for more details.
            
            @see #getDecomposition
            @see #setDecomposition(int)
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetFrenchCollationDefault">
            Sets the French collation mode to the initial mode set during construction of the RuleBasedCollator. See
            setFrenchCollation(boolean) for more details.
            
            @see #isFrenchCollation
            @see #setFrenchCollation(boolean)
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetStrengthDefault">
            Sets the collation strength to the initial mode set during the construction of the RuleBasedCollator. See
            setStrength(int) for more details.
            
            @see #setStrength(int)
            @see #getStrength
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetNumericCollationDefault">
             Method to set numeric collation to its default value.
            
             @see #getNumericCollation
             @see #setNumericCollation
             @stable ICU 2.8
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsFrenchCollation">
            Sets the mode for the direction of SECONDARY weights to be used in French collation. The default value is false,
            which treats SECONDARY weights in the order they appear. If set to true, the SECONDARY weights will be sorted
            backwards. See the section on <a href="http://userguide.icu-project.org/collation/architecture">
            French collation</a> for more information.
            
            @param flag
                       true to set the French collation on, false to set it off
            @stable ICU 2.8
            @see #isFrenchCollation
            @see #setFrenchCollationDefault
        </member>
        <member name="P:ICU4N.Text.RuleBasedCollator.IsAlternateHandlingShifted">
            Sets the alternate handling for QUATERNARY strength to be either shifted or non-ignorable. See the UCA definition
            on <a href="http://www.unicode.org/unicode/reports/tr10/#Variable_Weighting">Variable Weighting</a>. This
            attribute will only be effective when QUATERNARY strength is set. The default value for this mode is false,
            corresponding to the NON_IGNORABLE mode in UCA. In the NON_IGNORABLE mode, the RuleBasedCollator treats all
            the code points with non-ignorable primary weights in the same way. If the mode is set to true, the behavior
            corresponds to SHIFTED defined in UCA, this causes code points with PRIMARY orders that are equal or below the
            variable top value to be ignored in PRIMARY order and moved to the QUATERNARY order.
            
            @param shifted
                       true if SHIFTED behavior for alternate handling is desired, false for the NON_IGNORABLE behavior.
            @see #isAlternateHandlingShifted
            @see #setAlternateHandlingDefault
            @stable ICU 2.8
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Text.RuleBasedCollator.IsCaseLevel" -->
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Text.RuleBasedCollator.Decomposition" -->
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Text.RuleBasedCollator.Strength" -->
        <member name="P:ICU4N.Text.RuleBasedCollator.MaxVariable">
            {@icu} Sets the variable top to the top of the specified reordering group.
            The variable top determines the highest-sorting character
            which is affected by the alternate handling behavior.
            If that attribute is set to NON_IGNORABLE, then the variable top has no effect.
            @param group one of Collator.ReorderCodes.SPACE, Collator.ReorderCodes.PUNCTUATION,
                         Collator.ReorderCodes.SYMBOL, Collator.ReorderCodes.CURRENCY;
                         or Collator.ReorderCodes.DEFAULT to restore the default max variable group
            @return this
            @see #getMaxVariable
            @stable ICU 53
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.RuleBasedCollator.SetVariableTop(System.String)" -->
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Text.RuleBasedCollator.VariableTop" -->
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Text.RuleBasedCollator.IsNumericCollation" -->
        <member name="M:ICU4N.Text.RuleBasedCollator.SetReorderCodes(System.Int32[])">
             {@inheritDoc}
            
             @param order the reordering codes to apply to this collator; if this is null or an empty array
             then this clears any existing reordering
             @throws IllegalArgumentException if the reordering codes are malformed in any way (e.g. duplicates, multiple reset codes, overlapping equivalent scripts)
             @see #getReorderCodes
             @see Collator#getEquivalentReorderCodes
             @see Collator.ReorderCodes
             @see UScript
             @stable ICU 4.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetRules">
            Gets the collation tailoring rules for this RuleBasedCollator.
            Equivalent to String getRules(false).
            
            @return the collation tailoring rules
            @see #getRules(boolean)
            @stable ICU 2.8
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.RuleBasedCollator.GetRules(System.Boolean)" -->
        <member name="M:ICU4N.Text.RuleBasedCollator.GetTailoredSet">
            Get a UnicodeSet that contains all the characters and sequences tailored in this collator.
            
            @return a pointer to a UnicodeSet object containing all the code points and sequences that may sort differently
                    than in the root collator.
            @stable ICU 2.4
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetContractionsAndExpansions(ICU4N.Text.UnicodeSet,ICU4N.Text.UnicodeSet,System.Boolean)">
            Gets unicode sets containing contractions and/or expansions of a collator
            
            @param contractions
                       if not null, set to contain contractions
            @param expansions
                       if not null, set to contain expansions
            @param addPrefixes
                       add the prefix contextual elements to contractions
            @throws Exception
                        Throws an exception if any errors occurs.
            @stable ICU 3.4
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.InternalAddContractions(System.Int32,ICU4N.Text.UnicodeSet)">
            Adds the contractions that start with character c to the set.
            Ignores prefixes. Used by AlphabeticIndex.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.RuleBasedCollator.GetCollationKey(System.String)" -->
        <member name="M:ICU4N.Text.RuleBasedCollator.GetRawCollationKey(System.String,ICU4N.Text.RawCollationKey)">
            Gets the simpler form of a CollationKey for the String source following the rules of this Collator and stores the
            result into the user provided argument key. If key has a internal byte array of length that's too small for the
            result, the internal byte array will be grown to the exact required size.
            
            @param source the text String to be transformed into a RawCollationKey
            @param key output RawCollationKey to store results
            @return If key is null, a new instance of RawCollationKey will be created and returned, otherwise the user
                    provided key will be returned.
            @see #getCollationKey
            @see #compare(String, String)
            @see RawCollationKey
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.InternalGetCEs(ICU4N.Support.Text.ICharSequence)">
            Returns the CEs for the string.
            @param str the string
            @internal for tests &amp; tools
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetReorderCodes">
            Retrieves the reordering codes for this collator.
            These reordering codes are a combination of UScript codes and ReorderCodes.
            @return a copy of the reordering codes for this collator; 
            if none are set then returns an empty array
            @see #setReorderCodes
            @see Collator#getEquivalentReorderCodes
            @stable ICU 4.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.Equals(System.Object)">
            {@inheritDoc}
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetHashCode">
            Generates a unique hash code for this RuleBasedCollator.
            
            @return the unique hash code for this Collator
            @stable ICU 2.8
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.RuleBasedCollator.Compare(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:ICU4N.Text.RuleBasedCollator.NFDIterator" -->
        <member name="M:ICU4N.Text.RuleBasedCollator.NFDIterator.#ctor">
            Partial constructor, must call reset().
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.NFDIterator.NextCodePoint">
            Returns the next code point from the internal normalization buffer,
            or else the next text code point.
            Returns -1 at the end of the text.
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.NFDIterator.NextDecomposedCodePoint(ICU4N.Impl.Normalizer2Impl,System.Int32)">
            @param nfcImpl
            @param c the last code point returned by nextCodePoint() or nextDecomposedCodePoint()
            @return the first code point in c's decomposition,
                    or c itself if it was decomposed already or if it does not decompose
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.NFDIterator.NextRawCodePoint">
            Returns the next text code point in FCD order.
            Returns -1 at the end of the text.
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.DoCompare(ICU4N.Support.Text.ICharSequence,ICU4N.Support.Text.ICharSequence)">
            Compares two CharSequences.
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.IsUnsafe(System.Int32)">
             Tests whether a character is "unsafe" for use as a collation starting point.
            
             @param c code point or code unit
             @return true if c is unsafe
             @see CollationElementIterator#setOffset(int)
        </member>
        <member name="F:ICU4N.Text.RuleBasedCollator.frozenLock">
            Frozen state of the collator.
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetVersion">
            Get the version of this collator object.
            
            @return the version object associated with this collator
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetUCAVersion">
            Get the UCA version of this collator object.
            
            @return the version object associated with this collator
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.GetLocale(ICU4N.Util.ULocale.Type)">
            {@inheritDoc}
            @draft ICU 53 (retain)
            @provisional This API might change or be removed in a future release.
        </member>
        <member name="M:ICU4N.Text.RuleBasedCollator.SetLocale(ICU4N.Util.ULocale,ICU4N.Util.ULocale)">
            {@inheritDoc}
        </member>
        <member name="F:ICU4N.Text.SearchIterator.m_breakIterator">
            The BreakIterator to define the boundaries of a logical match.
            This value can be a null.
            See class documentation for more information.
            @see #setBreakIterator(BreakIterator)
            @see #getBreakIterator
            @see BreakIterator
            @stable ICU 2.0
        </member>
        <member name="F:ICU4N.Text.SearchIterator.m_targetText">
            Target text for searching.
            @see #setTarget(CharacterIterator)
            @see #getTarget
            @stable ICU 2.0
        </member>
        <member name="F:ICU4N.Text.SearchIterator.m_matchLength">
            Length of the most current match in target text. 
            Value 0 is the default value.
            @see #setMatchLength
            @see #getMatchLength
            @stable ICU 2.0
        </member>
        <member name="T:ICU4N.Text.SearchIterator.Search">
            Java port of ICU4C struct USearch (usrchimp.h)
            
            Note:
            
             ICU4J already exposed some protected members such as
            targetText, breakIterator and matchedLength as a part of stable
            APIs. In ICU4C, they are exposed through USearch struct, 
            although USearch struct itself is internal API.
            
             This class was created for making ICU4J code parallel to
            ICU4C implementation. ICU4J implementation access member
            fields like C struct (e.g. search_.isOverlap_) mostly, except
            fields already exposed as protected member (e.g. search_.text()).
            
        </member>
        <member name="F:ICU4N.Text.SearchIterator.Search.isOverlap_">
            Flag to indicate if overlapping search is to be done.
                            E.g. looking for "aa" in "aaa" will yield matches at offset 0 and 1. 
        </member>
        <member name="F:ICU4N.Text.SearchIterator.Search.isForwardSearching_">
            Flag indicates if we are doing a forwards search 
        </member>
        <member name="F:ICU4N.Text.SearchIterator.Search.reset_">
            Flag indicates if we are at the start of a string search.
                            This indicates that we are in forward search and at the start of m_text. 
        </member>
        <member name="F:ICU4N.Text.SearchIterator.Done">
            DONE is returned by previous() and next() after all valid matches have 
            been returned, and by first() and last() if there are no matches at all.
            @see #previous
            @see #next
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.SearchIterator.SetIndex(System.Int32)">
            <p>
            Sets the position in the target text at which the next search will start.
            This method clears any previous match.
            </p>
            @param position position from which to start the next search
            @exception IndexOutOfBoundsException thrown if argument position is out
                       of the target text range.
            @see #getIndex
            @stable ICU 2.8
        </member>
        <!-- Badly formed XML comment ignored for member "P:ICU4N.Text.SearchIterator.MatchStart" -->
        <member name="P:ICU4N.Text.SearchIterator.Index">
            Return the current index in the text being searched.
            If the iteration has gone past the end of the text
            (or past the beginning for a backwards search), {@link #DONE}
            is returned.
            
            @return current index in the text being searched.
            @stable ICU 2.8
        </member>
        <member name="P:ICU4N.Text.SearchIterator.MatchLength">
            Returns the length of text in the string which matches the search 
            pattern. This call returns a valid result only after a successful call 
            to {@link #first}, {@link #next}, {@link #previous}, or {@link #last}.
            Just after construction, or after a searching method returns 
            {@link #DONE}, this method will return 0.
            
            @return The length of the match in the target text, or 0 if there
                    is no match currently.
            @see #first
            @see #next
            @see #previous
            @see #last
            @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.SearchIterator.BreakIterator">
            Returns the BreakIterator that is used to restrict the indexes at which 
            matches are detected. This will be the same object that was passed to 
            the constructor or to {@link #setBreakIterator}.
            If the {@link BreakIterator} has not been set, <tt>null</tt> will be returned.
            See {@link #setBreakIterator} for more information.
            
            @return the BreakIterator set to restrict logic matches
            @see #setBreakIterator
            @see BreakIterator
            @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.SearchIterator.Target">
            Return the string text to be searched.
            @return text string to be searched.
            @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.SearchIterator.MatchedText">
            Returns the text that was matched by the most recent call to 
            {@link #first}, {@link #next}, {@link #previous}, or {@link #last}.
            If the iterator is not pointing at a valid match (e.g. just after 
            construction or after {@link #DONE} has been returned, 
            returns an empty string. 
            
            @return  the substring in the target test of the most recent match,
                     or null if there is no match currently.
            @see #first
            @see #next
            @see #previous
            @see #last
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Next">
            Returns the index of the next point at which the text matches the
            search pattern, starting from the current position
            The iterator is adjusted so that its current index (as returned by 
            {@link #getIndex}) is the match position if one was found.
            If a match is not found, {@link #DONE} will be returned and
            the iterator will be adjusted to a position after the end of the text 
            string.
            
            @return The index of the next match after the current position,
                     or {@link #DONE} if there are no more matches.
            @see #getIndex
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Previous">
            Returns the index of the previous point at which the string text 
            matches the search pattern, starting at the current position.
            The iterator is adjusted so that its current index (as returned by 
            {@link #getIndex}) is the match position if one was found.
            If a match is not found, {@link #DONE} will be returned and
            the iterator will be adjusted to the index {@link #DONE}.
            
            @return The index of the previous match before the current position,
                     or {@link #DONE} if there are no more matches.
            @see #getIndex
            @stable ICU 2.0
        </member>
        <member name="P:ICU4N.Text.SearchIterator.IsOverlapping">
            Return true if the overlapping property has been set.
            See {@link #setOverlapping(boolean)} for more information.
            
            @see #setOverlapping
            @return true if the overlapping property has been set, false otherwise
            @stable ICU 2.8
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Reset">
            Resets the iteration.
            Search will begin at the start of the text string if a forward
            iteration is initiated before a backwards iteration. Otherwise if a
            backwards iteration is initiated before a forwards iteration, the
            search will begin at the end of the text string.
            
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.SearchIterator.First">
            Returns the first index at which the string text matches the search 
            pattern. The iterator is adjusted so that its current index (as 
            returned by {@link #getIndex()}) is the match position if one 
            
            was found.
            If a match is not found, {@link #DONE} will be returned and
            the iterator will be adjusted to the index {@link #DONE}.
            @return The character index of the first match, or 
                    {@link #DONE} if there are no matches.
            
            @see #getIndex
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Following(System.Int32)">
            Returns the first index equal or greater than <tt>position</tt> at which the 
            string text matches the search pattern. The iterator is adjusted so 
            that its current index (as returned by {@link #getIndex()}) is the 
            match position if one was found.
            If a match is not found, {@link #DONE} will be returned and the
            iterator will be adjusted to the index {@link #DONE}.
            
            @param  position where search if to start from.
            @return The character index of the first match following 
                    <tt>position</tt>, or {@link #DONE} if there are no matches.
            @throws IndexOutOfBoundsException    If position is less than or greater
                 than the text range for searching.
            @see #getIndex
            @stable ICU 2.0
        </member>
        <member name="M:ICU4N.Text.SearchIterator.Last">
            Returns the last index in the target text at which it matches the
            search pattern. The iterator is adjusted so that its current index
            (as returned by {@link #getIndex}) is the match position if one was
            found.
            If a match is not found, {@link #DONE} will be returned and
            the iterator will be adjusted to the index {@link #DONE}.
            
            @return The index of the first match, or {@link #DONE} if 
                    there are no matches.
            @see #getIndex
            @stable ICU 2.0
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.SearchIterator.Preceding(System.Int32)" -->
        <member name="M:ICU4N.Text.SearchIterator.#ctor(ICU4N.Support.Text.CharacterIterator,ICU4N.Text.BreakIterator)">
            Protected constructor for use by subclasses.
            Initializes the iterator with the argument target text for searching 
            and sets the BreakIterator.
            See class documentation for more details on the use of the target text
            and {@link BreakIterator}.
            
            @param target The target text to be searched.
            @param breaker A {@link BreakIterator} that is used to determine the 
                           boundaries of a logical match. This argument can be null.
            @exception IllegalArgumentException thrown when argument target is null,
                       or of length 0
            @see BreakIterator  
            @stable ICU 2.0
        </member>
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.SearchIterator.HandleNext(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:ICU4N.Text.SearchIterator.HandlePrevious(System.Int32)" -->
        <member name="M:ICU4N.Text.SearchIterator.SetMatchNotFound">
            @internal
            @deprecated This API is ICU internal only.
        </member>
        <member name="P:ICU4N.Text.SearchIterator.ElementComparisonType">
            **
        </member>
        <!-- Badly formed XML comment ignored for member "T:ICU4N.Text.SearchIteratorElementComparisonType" -->
        <member name="F:ICU4N.Text.SearchIteratorElementComparisonType.StandardElementComparison">
            Standard collation element comparison at the specified collator strength.
            
            @stable ICU 53
        </member>
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Text.SearchIteratorElementComparisonType.PatternBaseWeightIsWildcard" -->
        <!-- Badly formed XML comment ignored for member "F:ICU4N.Text.SearchIteratorElementComparisonType.AnyBaseWeightIsWildcard" -->
    </members>
</doc>
